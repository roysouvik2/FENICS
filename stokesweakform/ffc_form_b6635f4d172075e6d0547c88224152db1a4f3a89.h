// This code conforms with the UFC specification version 2.0.5
// and was automatically generated by FFC version 1.0.0.
// 
// This code was generated with the following parameters:
// 
//   cache_dir:                      ''
//   convert_exceptions_to_warnings: False
//   cpp_optimize:                   False
//   cpp_optimize_flags:             '-O2'
//   epsilon:                        1e-14
//   error_control:                  False
//   form_postfix:                   False
//   format:                         'ufc'
//   log_level:                      25
//   log_prefix:                     ''
//   name:                           'ffc'
//   no-evaluate_basis_derivatives:  True
//   optimize:                       False
//   output_dir:                     '.'
//   precision:                      15
//   quadrature_degree:              -1
//   quadrature_rule:                'auto'
//   representation:                 'auto'
//   split:                          False
//   swig_binary:                    'swig2.0'
//   swig_path:                      ''

#ifndef __FFC_FORM_B6635F4D172075E6D0547C88224152DB1A4F3A89_H
#define __FFC_FORM_B6635F4D172075E6D0547C88224152DB1A4F3A89_H

#include <cmath>
#include <stdexcept>
#include <fstream>
#include <ufc.h>

/// This class defines the interface for a finite element.

class ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_0: public ufc::finite_element
{
public:

  /// Constructor
  ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_0() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_0()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 3;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    *values = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.0, 0.333333333333333};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.0;
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 3; r++)
    {
      evaluate_basis(r, &dof_values, coordinates, c);
      values[r] = dof_values;
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
throw std::runtime_error("// Function evaluate_basis_derivatives not generated (compiled with -fno-evaluate_basis_derivatives)");
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      dof_values[r] = 0.0;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 3; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_0();
  }

};

/// This class defines the interface for a finite element.

class ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_1: public ufc::finite_element
{
public:

  /// Constructor
  ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_1() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_1()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 6;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    *values = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.0;
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 6; r++)
    {
      evaluate_basis(r, &dof_values, coordinates, c);
      values[r] = dof_values;
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
throw std::runtime_error("// Function evaluate_basis_derivatives not generated (compiled with -fno-evaluate_basis_derivatives)");
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      dof_values[r] = 0.0;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 6; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.5*x[1][0] + 0.5*x[2][0];
      y[1] = 0.5*x[1][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[2][0];
      y[1] = 0.5*x[0][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[1][0];
      y[1] = 0.5*x[0][1] + 0.5*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.5*x[1][0] + 0.5*x[2][0];
    y[1] = 0.5*x[1][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*x[0][0] + 0.5*x[2][0];
    y[1] = 0.5*x[0][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5*x[0][0] + 0.5*x[1][0];
    y[1] = 0.5*x[0][1] + 0.5*x[1][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_1();
  }

};

/// This class defines the interface for a finite element.

class ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_2: public ufc::finite_element
{
public:

  /// Constructor
  ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_2() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_2()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 12;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return 2;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    values[0] = 0.0;
    values[1] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {0.0, 0.0};
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 12; r++)
    {
      evaluate_basis(r, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 2; s++)
      {
        values[r*2 + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
throw std::runtime_error("// Function evaluate_basis_derivatives not generated (compiled with -fno-evaluate_basis_derivatives)");
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[2*num_derivatives];
    for (unsigned int r = 0; r < 2*num_derivatives; r++)
    {
      dof_values[r] = 0.0;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 12; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 2*num_derivatives; s++)
      {
        values[r*2*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[2];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.5*x[1][0] + 0.5*x[2][0];
      y[1] = 0.5*x[1][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[2][0];
      y[1] = 0.5*x[0][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[1][0];
      y[1] = 0.5*x[0][1] + 0.5*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 7:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 8:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 9:
      {
        y[0] = 0.5*x[1][0] + 0.5*x[2][0];
      y[1] = 0.5*x[1][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 10:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[2][0];
      y[1] = 0.5*x[0][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[1][0];
      y[1] = 0.5*x[0][1] + 0.5*x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[2];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.5*x[1][0] + 0.5*x[2][0];
    y[1] = 0.5*x[1][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*x[0][0] + 0.5*x[2][0];
    y[1] = 0.5*x[0][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5*x[0][0] + 0.5*x[1][0];
    y[1] = 0.5*x[0][1] + 0.5*x[1][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[8] = vals[1];
    y[0] = 0.5*x[1][0] + 0.5*x[2][0];
    y[1] = 0.5*x[1][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[9] = vals[1];
    y[0] = 0.5*x[0][0] + 0.5*x[2][0];
    y[1] = 0.5*x[0][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = 0.5*x[0][0] + 0.5*x[1][0];
    y[1] = 0.5*x[0][1] + 0.5*x[1][1];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[1];
    vertex_values[4] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[6];
    vertex_values[3] = dof_values[7];
    vertex_values[5] = dof_values[8];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_1();
        break;
      }
    case 1:
      {
        return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_1();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_2();
  }

};

/// This class defines the interface for a finite element.

class ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_3: public ufc::finite_element
{
public:

  /// Constructor
  ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_3() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_3()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None)], **{'value_shape': (5,) })";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 27;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return 5;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    values[0] = 0.0;
    values[1] = 0.0;
    values[2] = 0.0;
    values[3] = 0.0;
    values[4] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.0, 0.333333333333333};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 15:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[3] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 16:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[3] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 17:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[3] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 18:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[3] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 19:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[3] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 20:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[3] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 21:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[4] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 22:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[4] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 23:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[4] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 24:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[4] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 25:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[4] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 26:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[4] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values[5] = {0.0, 0.0, 0.0, 0.0, 0.0};
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 27; r++)
    {
      evaluate_basis(r, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 5; s++)
      {
        values[r*5 + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
throw std::runtime_error("// Function evaluate_basis_derivatives not generated (compiled with -fno-evaluate_basis_derivatives)");
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[5*num_derivatives];
    for (unsigned int r = 0; r < 5*num_derivatives; r++)
    {
      dof_values[r] = 0.0;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 27; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 5*num_derivatives; s++)
      {
        values[r*5*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[5];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.5*x[1][0] + 0.5*x[2][0];
      y[1] = 0.5*x[1][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[2][0];
      y[1] = 0.5*x[0][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[1][0];
      y[1] = 0.5*x[0][1] + 0.5*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 7:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 8:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 9:
      {
        y[0] = 0.5*x[1][0] + 0.5*x[2][0];
      y[1] = 0.5*x[1][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 10:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[2][0];
      y[1] = 0.5*x[0][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[1][0];
      y[1] = 0.5*x[0][1] + 0.5*x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 12:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 13:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 14:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 15:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[3];
        break;
      }
    case 16:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[3];
        break;
      }
    case 17:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[3];
        break;
      }
    case 18:
      {
        y[0] = 0.5*x[1][0] + 0.5*x[2][0];
      y[1] = 0.5*x[1][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[3];
        break;
      }
    case 19:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[2][0];
      y[1] = 0.5*x[0][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[3];
        break;
      }
    case 20:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[1][0];
      y[1] = 0.5*x[0][1] + 0.5*x[1][1];
      f.evaluate(vals, y, c);
      return vals[3];
        break;
      }
    case 21:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[4];
        break;
      }
    case 22:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[4];
        break;
      }
    case 23:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[4];
        break;
      }
    case 24:
      {
        y[0] = 0.5*x[1][0] + 0.5*x[2][0];
      y[1] = 0.5*x[1][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[4];
        break;
      }
    case 25:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[2][0];
      y[1] = 0.5*x[0][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[4];
        break;
      }
    case 26:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[1][0];
      y[1] = 0.5*x[0][1] + 0.5*x[1][1];
      f.evaluate(vals, y, c);
      return vals[4];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[5];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.5*x[1][0] + 0.5*x[2][0];
    y[1] = 0.5*x[1][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*x[0][0] + 0.5*x[2][0];
    y[1] = 0.5*x[0][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5*x[0][0] + 0.5*x[1][0];
    y[1] = 0.5*x[0][1] + 0.5*x[1][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[8] = vals[1];
    y[0] = 0.5*x[1][0] + 0.5*x[2][0];
    y[1] = 0.5*x[1][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[9] = vals[1];
    y[0] = 0.5*x[0][0] + 0.5*x[2][0];
    y[1] = 0.5*x[0][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = 0.5*x[0][0] + 0.5*x[1][0];
    y[1] = 0.5*x[0][1] + 0.5*x[1][1];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[12] = vals[2];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[13] = vals[2];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[14] = vals[2];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[15] = vals[3];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[16] = vals[3];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[17] = vals[3];
    y[0] = 0.5*x[1][0] + 0.5*x[2][0];
    y[1] = 0.5*x[1][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[18] = vals[3];
    y[0] = 0.5*x[0][0] + 0.5*x[2][0];
    y[1] = 0.5*x[0][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[19] = vals[3];
    y[0] = 0.5*x[0][0] + 0.5*x[1][0];
    y[1] = 0.5*x[0][1] + 0.5*x[1][1];
    f.evaluate(vals, y, c);
    values[20] = vals[3];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[21] = vals[4];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[22] = vals[4];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[23] = vals[4];
    y[0] = 0.5*x[1][0] + 0.5*x[2][0];
    y[1] = 0.5*x[1][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[24] = vals[4];
    y[0] = 0.5*x[0][0] + 0.5*x[2][0];
    y[1] = 0.5*x[0][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[25] = vals[4];
    y[0] = 0.5*x[0][0] + 0.5*x[1][0];
    y[1] = 0.5*x[0][1] + 0.5*x[1][1];
    f.evaluate(vals, y, c);
    values[26] = vals[4];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[5] = dof_values[1];
    vertex_values[10] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[6];
    vertex_values[6] = dof_values[7];
    vertex_values[11] = dof_values[8];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[12];
    vertex_values[7] = dof_values[13];
    vertex_values[12] = dof_values[14];
    // Evaluate function and change variables
    vertex_values[3] = dof_values[15];
    vertex_values[8] = dof_values[16];
    vertex_values[13] = dof_values[17];
    // Evaluate function and change variables
    vertex_values[4] = dof_values[21];
    vertex_values[9] = dof_values[22];
    vertex_values[14] = dof_values[23];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 3;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_2();
        break;
      }
    case 1:
      {
        return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_0();
        break;
      }
    case 2:
      {
        return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_2();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_3();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_0: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_0() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_0()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = m.num_entities[0];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 3;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 3;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 2;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 1;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = c.entity_indices[0][0];
    dofs[1] = c.entity_indices[0][1];
    dofs[2] = c.entity_indices[0][2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_0();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_1: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_1() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_1()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = m.num_entities[0] + m.num_entities[1];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 6;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 6;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 3;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 1;
        break;
      }
    case 1:
      {
        return 1;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[3] = offset + c.entity_indices[1][0];
    dofs[4] = offset + c.entity_indices[1][1];
    dofs[5] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 4;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 5;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
          break;
        }
      case 1:
        {
          dofs[0] = 4;
          break;
        }
      case 2:
        {
          dofs[0] = 5;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[3][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[4][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[4][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[5][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[5][1] = 0.5*x[0][1] + 0.5*x[1][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_1();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_2: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_2() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_2()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = 2*m.num_entities[0] + 2*m.num_entities[1];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 12;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 12;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 6;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 2;
        break;
      }
    case 1:
      {
        return 2;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[3] = offset + c.entity_indices[1][0];
    dofs[4] = offset + c.entity_indices[1][1];
    dofs[5] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
    dofs[6] = offset + c.entity_indices[0][0];
    dofs[7] = offset + c.entity_indices[0][1];
    dofs[8] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[9] = offset + c.entity_indices[1][0];
    dofs[10] = offset + c.entity_indices[1][1];
    dofs[11] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 7;
      dofs[4] = 8;
      dofs[5] = 9;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 4;
      dofs[3] = 6;
      dofs[4] = 8;
      dofs[5] = 10;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 5;
      dofs[3] = 6;
      dofs[4] = 7;
      dofs[5] = 11;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 6;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 7;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 8;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 9;
          break;
        }
      case 1:
        {
          dofs[0] = 4;
        dofs[1] = 10;
          break;
        }
      case 2:
        {
          dofs[0] = 5;
        dofs[1] = 11;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[3][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[4][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[4][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[5][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[5][1] = 0.5*x[0][1] + 0.5*x[1][1];
    coordinates[6][0] = x[0][0];
    coordinates[6][1] = x[0][1];
    coordinates[7][0] = x[1][0];
    coordinates[7][1] = x[1][1];
    coordinates[8][0] = x[2][0];
    coordinates[8][1] = x[2][1];
    coordinates[9][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[9][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[10][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[10][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[11][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[11][1] = 0.5*x[0][1] + 0.5*x[1][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_1();
        break;
      }
    case 1:
      {
        return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_1();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_2();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_3: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_3() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_3()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None)], **{'value_shape': (5,) })";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = 5*m.num_entities[0] + 4*m.num_entities[1];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 27;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 27;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 14;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 5;
        break;
      }
    case 1:
      {
        return 4;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[3] = offset + c.entity_indices[1][0];
    dofs[4] = offset + c.entity_indices[1][1];
    dofs[5] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
    dofs[6] = offset + c.entity_indices[0][0];
    dofs[7] = offset + c.entity_indices[0][1];
    dofs[8] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[9] = offset + c.entity_indices[1][0];
    dofs[10] = offset + c.entity_indices[1][1];
    dofs[11] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
    dofs[12] = offset + c.entity_indices[0][0];
    dofs[13] = offset + c.entity_indices[0][1];
    dofs[14] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[15] = offset + c.entity_indices[0][0];
    dofs[16] = offset + c.entity_indices[0][1];
    dofs[17] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[18] = offset + c.entity_indices[1][0];
    dofs[19] = offset + c.entity_indices[1][1];
    dofs[20] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
    dofs[21] = offset + c.entity_indices[0][0];
    dofs[22] = offset + c.entity_indices[0][1];
    dofs[23] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[24] = offset + c.entity_indices[1][0];
    dofs[25] = offset + c.entity_indices[1][1];
    dofs[26] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 7;
      dofs[4] = 8;
      dofs[5] = 9;
      dofs[6] = 13;
      dofs[7] = 14;
      dofs[8] = 16;
      dofs[9] = 17;
      dofs[10] = 18;
      dofs[11] = 22;
      dofs[12] = 23;
      dofs[13] = 24;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 4;
      dofs[3] = 6;
      dofs[4] = 8;
      dofs[5] = 10;
      dofs[6] = 12;
      dofs[7] = 14;
      dofs[8] = 15;
      dofs[9] = 17;
      dofs[10] = 19;
      dofs[11] = 21;
      dofs[12] = 23;
      dofs[13] = 25;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 5;
      dofs[3] = 6;
      dofs[4] = 7;
      dofs[5] = 11;
      dofs[6] = 12;
      dofs[7] = 13;
      dofs[8] = 15;
      dofs[9] = 16;
      dofs[10] = 20;
      dofs[11] = 21;
      dofs[12] = 22;
      dofs[13] = 26;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 6;
        dofs[2] = 12;
        dofs[3] = 15;
        dofs[4] = 21;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 7;
        dofs[2] = 13;
        dofs[3] = 16;
        dofs[4] = 22;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 8;
        dofs[2] = 14;
        dofs[3] = 17;
        dofs[4] = 23;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 9;
        dofs[2] = 18;
        dofs[3] = 24;
          break;
        }
      case 1:
        {
          dofs[0] = 4;
        dofs[1] = 10;
        dofs[2] = 19;
        dofs[3] = 25;
          break;
        }
      case 2:
        {
          dofs[0] = 5;
        dofs[1] = 11;
        dofs[2] = 20;
        dofs[3] = 26;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[3][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[4][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[4][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[5][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[5][1] = 0.5*x[0][1] + 0.5*x[1][1];
    coordinates[6][0] = x[0][0];
    coordinates[6][1] = x[0][1];
    coordinates[7][0] = x[1][0];
    coordinates[7][1] = x[1][1];
    coordinates[8][0] = x[2][0];
    coordinates[8][1] = x[2][1];
    coordinates[9][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[9][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[10][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[10][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[11][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[11][1] = 0.5*x[0][1] + 0.5*x[1][1];
    coordinates[12][0] = x[0][0];
    coordinates[12][1] = x[0][1];
    coordinates[13][0] = x[1][0];
    coordinates[13][1] = x[1][1];
    coordinates[14][0] = x[2][0];
    coordinates[14][1] = x[2][1];
    coordinates[15][0] = x[0][0];
    coordinates[15][1] = x[0][1];
    coordinates[16][0] = x[1][0];
    coordinates[16][1] = x[1][1];
    coordinates[17][0] = x[2][0];
    coordinates[17][1] = x[2][1];
    coordinates[18][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[18][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[19][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[19][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[20][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[20][1] = 0.5*x[0][1] + 0.5*x[1][1];
    coordinates[21][0] = x[0][0];
    coordinates[21][1] = x[0][1];
    coordinates[22][0] = x[1][0];
    coordinates[22][1] = x[1][1];
    coordinates[23][0] = x[2][0];
    coordinates[23][1] = x[2][1];
    coordinates[24][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[24][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[25][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[25][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[26][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[26][1] = 0.5*x[0][1] + 0.5*x[1][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 3;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_2();
        break;
      }
    case 1:
      {
        return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_0();
        break;
      }
    case 2:
      {
        return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_2();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_3();
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_cell_integral_0_0: public ufc::cell_integral
{
public:

  /// Constructor
  ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_cell_integral_0_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_cell_integral_0_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      11
    // Number of operations (multiply-add pairs) for geometry tensor:    32
    // Number of operations (multiply-add pairs) for tensor contraction: 282
    // Total number of operations (multiply-add pairs):                  325
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute geometry tensor
    const double G0_0 = det*K_00*(1.0);
    const double G0_1 = det*K_10*(1.0);
    const double G1_0 = det*K_01*(1.0);
    const double G1_1 = det*K_11*(1.0);
    const double G2_0_0 = det*K_00*K_00*(1.0);
    const double G2_0_1 = det*K_00*K_10*(1.0);
    const double G2_1_0 = det*K_10*K_00*(1.0);
    const double G2_1_1 = det*K_10*K_10*(1.0);
    const double G3_0_0 = det*K_00*K_00*(1.0);
    const double G3_0_1 = det*K_00*K_10*(1.0);
    const double G3_1_0 = det*K_10*K_00*(1.0);
    const double G3_1_1 = det*K_10*K_10*(1.0);
    const double G4_0_0 = det*K_01*K_01*(1.0);
    const double G4_0_1 = det*K_01*K_11*(1.0);
    const double G4_1_0 = det*K_11*K_01*(1.0);
    const double G4_1_1 = det*K_11*K_11*(1.0);
    const double G5_0_0 = det*K_01*K_01*(1.0);
    const double G5_0_1 = det*K_01*K_11*(1.0);
    const double G5_1_0 = det*K_11*K_01*(1.0);
    const double G5_1_1 = det*K_11*K_11*(1.0);
    const double G6_0 = det*K_00*(1.0);
    const double G6_1 = det*K_10*(1.0);
    const double G7_0 = det*K_01*(1.0);
    const double G7_1 = det*K_11*(1.0);
    
    // Compute element tensor
    A[0] = 0.000499999999999999*G2_0_0 + 0.0005*G2_0_1 + 0.0005*G2_1_0 + 0.0005*G2_1_1 + 0.000499999999999999*G4_0_0 + 0.0005*G4_0_1 + 0.0005*G4_1_0 + 0.0005*G4_1_1;
    A[1] = 0.000166666666666666*G2_0_0 + 0.000166666666666667*G2_1_0 + 0.000166666666666666*G4_0_0 + 0.000166666666666667*G4_1_0;
    A[2] = 0.000166666666666666*G2_0_1 + 0.000166666666666666*G2_1_1 + 0.000166666666666666*G4_0_1 + 0.000166666666666666*G4_1_1;
    A[3] = 0.0;
    A[4] = -0.000666666666666666*G2_0_1 - 0.000666666666666666*G2_1_1 - 0.000666666666666666*G4_0_1 - 0.000666666666666666*G4_1_1;
    A[5] = -0.000666666666666666*G2_0_0 - 0.000666666666666666*G2_1_0 - 0.000666666666666666*G4_0_0 - 0.000666666666666666*G4_1_0;
    A[6] = 0.0;
    A[7] = 0.0;
    A[8] = 0.0;
    A[9] = 0.0;
    A[10] = 0.0;
    A[11] = 0.0;
    A[12] = 0.166666666666667*G6_0 + 0.166666666666667*G6_1;
    A[13] = 0.0;
    A[14] = 0.0;
    A[15] = 0.0;
    A[16] = 0.0;
    A[17] = 0.0;
    A[18] = 0.0;
    A[19] = 0.0;
    A[20] = 0.0;
    A[21] = 0.0;
    A[22] = 0.0;
    A[23] = 0.0;
    A[24] = 0.0;
    A[25] = 0.0;
    A[26] = 0.0;
    A[27] = 0.000166666666666666*G2_0_0 + 0.000166666666666667*G2_0_1 + 0.000166666666666666*G4_0_0 + 0.000166666666666667*G4_0_1;
    A[28] = 0.000499999999999999*G2_0_0 + 0.000499999999999999*G4_0_0;
    A[29] = -0.000166666666666666*G2_0_1 - 0.000166666666666666*G4_0_1;
    A[30] = 0.000666666666666666*G2_0_1 + 0.000666666666666666*G4_0_1;
    A[31] = 0.0;
    A[32] = -0.000666666666666666*G2_0_0 - 0.000666666666666666*G2_0_1 - 0.000666666666666666*G4_0_0 - 0.000666666666666666*G4_0_1;
    A[33] = 0.0;
    A[34] = 0.0;
    A[35] = 0.0;
    A[36] = 0.0;
    A[37] = 0.0;
    A[38] = 0.0;
    A[39] = 0.0;
    A[40] = -0.166666666666666*G6_0;
    A[41] = 0.0;
    A[42] = 0.0;
    A[43] = 0.0;
    A[44] = 0.0;
    A[45] = 0.0;
    A[46] = 0.0;
    A[47] = 0.0;
    A[48] = 0.0;
    A[49] = 0.0;
    A[50] = 0.0;
    A[51] = 0.0;
    A[52] = 0.0;
    A[53] = 0.0;
    A[54] = 0.000166666666666666*G2_1_0 + 0.000166666666666666*G2_1_1 + 0.000166666666666666*G4_1_0 + 0.000166666666666666*G4_1_1;
    A[55] = -0.000166666666666666*G2_1_0 - 0.000166666666666666*G4_1_0;
    A[56] = 0.0005*G2_1_1 + 0.0005*G4_1_1;
    A[57] = 0.000666666666666666*G2_1_0 + 0.000666666666666666*G4_1_0;
    A[58] = -0.000666666666666666*G2_1_0 - 0.000666666666666666*G2_1_1 - 0.000666666666666666*G4_1_0 - 0.000666666666666666*G4_1_1;
    A[59] = 0.0;
    A[60] = 0.0;
    A[61] = 0.0;
    A[62] = 0.0;
    A[63] = 0.0;
    A[64] = 0.0;
    A[65] = 0.0;
    A[66] = 0.0;
    A[67] = 0.0;
    A[68] = -0.166666666666667*G6_1;
    A[69] = 0.0;
    A[70] = 0.0;
    A[71] = 0.0;
    A[72] = 0.0;
    A[73] = 0.0;
    A[74] = 0.0;
    A[75] = 0.0;
    A[76] = 0.0;
    A[77] = 0.0;
    A[78] = 0.0;
    A[79] = 0.0;
    A[80] = 0.0;
    A[81] = 0.0;
    A[82] = 0.000666666666666666*G2_1_0 + 0.000666666666666666*G4_1_0;
    A[83] = 0.000666666666666666*G2_0_1 + 0.000666666666666666*G4_0_1;
    A[84] = 0.00133333333333333*G2_0_0 + 0.000666666666666666*G2_0_1 + 0.000666666666666666*G2_1_0 + 0.00133333333333333*G2_1_1 + 0.00133333333333333*G4_0_0 + 0.000666666666666666*G4_0_1 + 0.000666666666666666*G4_1_0 + 0.00133333333333333*G4_1_1;
    A[85] = -0.00133333333333333*G2_0_0 - 0.000666666666666666*G2_0_1 - 0.000666666666666666*G2_1_0 - 0.00133333333333333*G4_0_0 - 0.000666666666666666*G4_0_1 - 0.000666666666666666*G4_1_0;
    A[86] = -0.000666666666666666*G2_0_1 - 0.000666666666666665*G2_1_0 - 0.00133333333333333*G2_1_1 - 0.000666666666666666*G4_0_1 - 0.000666666666666665*G4_1_0 - 0.00133333333333333*G4_1_1;
    A[87] = 0.0;
    A[88] = 0.0;
    A[89] = 0.0;
    A[90] = 0.0;
    A[91] = 0.0;
    A[92] = 0.0;
    A[93] = -0.166666666666667*G6_0 - 0.166666666666667*G6_1;
    A[94] = -0.166666666666667*G6_0 - 0.333333333333333*G6_1;
    A[95] = -0.333333333333333*G6_0 - 0.166666666666667*G6_1;
    A[96] = 0.0;
    A[97] = 0.0;
    A[98] = 0.0;
    A[99] = 0.0;
    A[100] = 0.0;
    A[101] = 0.0;
    A[102] = 0.0;
    A[103] = 0.0;
    A[104] = 0.0;
    A[105] = 0.0;
    A[106] = 0.0;
    A[107] = 0.0;
    A[108] = -0.000666666666666666*G2_1_0 - 0.000666666666666666*G2_1_1 - 0.000666666666666666*G4_1_0 - 0.000666666666666666*G4_1_1;
    A[109] = 0.0;
    A[110] = -0.000666666666666666*G2_0_1 - 0.000666666666666666*G2_1_1 - 0.000666666666666666*G4_0_1 - 0.000666666666666666*G4_1_1;
    A[111] = -0.00133333333333333*G2_0_0 - 0.000666666666666666*G2_0_1 - 0.000666666666666666*G2_1_0 - 0.00133333333333333*G4_0_0 - 0.000666666666666666*G4_0_1 - 0.000666666666666666*G4_1_0;
    A[112] = 0.00133333333333333*G2_0_0 + 0.000666666666666666*G2_0_1 + 0.000666666666666666*G2_1_0 + 0.00133333333333333*G2_1_1 + 0.00133333333333333*G4_0_0 + 0.000666666666666666*G4_0_1 + 0.000666666666666666*G4_1_0 + 0.00133333333333333*G4_1_1;
    A[113] = 0.000666666666666667*G2_0_1 + 0.000666666666666666*G2_1_0 + 0.000666666666666667*G4_0_1 + 0.000666666666666666*G4_1_0;
    A[114] = 0.0;
    A[115] = 0.0;
    A[116] = 0.0;
    A[117] = 0.0;
    A[118] = 0.0;
    A[119] = 0.0;
    A[120] = 0.166666666666667*G6_0 - 0.166666666666667*G6_1;
    A[121] = 0.166666666666667*G6_0;
    A[122] = 0.333333333333333*G6_0 + 0.166666666666666*G6_1;
    A[123] = 0.0;
    A[124] = 0.0;
    A[125] = 0.0;
    A[126] = 0.0;
    A[127] = 0.0;
    A[128] = 0.0;
    A[129] = 0.0;
    A[130] = 0.0;
    A[131] = 0.0;
    A[132] = 0.0;
    A[133] = 0.0;
    A[134] = 0.0;
    A[135] = -0.000666666666666666*G2_0_0 - 0.000666666666666666*G2_0_1 - 0.000666666666666666*G4_0_0 - 0.000666666666666666*G4_0_1;
    A[136] = -0.000666666666666666*G2_0_0 - 0.000666666666666666*G2_1_0 - 0.000666666666666666*G4_0_0 - 0.000666666666666666*G4_1_0;
    A[137] = 0.0;
    A[138] = -0.000666666666666666*G2_0_1 - 0.000666666666666666*G2_1_0 - 0.00133333333333333*G2_1_1 - 0.000666666666666666*G4_0_1 - 0.000666666666666666*G4_1_0 - 0.00133333333333333*G4_1_1;
    A[139] = 0.000666666666666666*G2_0_1 + 0.000666666666666667*G2_1_0 + 0.000666666666666666*G4_0_1 + 0.000666666666666667*G4_1_0;
    A[140] = 0.00133333333333333*G2_0_0 + 0.000666666666666666*G2_0_1 + 0.000666666666666666*G2_1_0 + 0.00133333333333333*G2_1_1 + 0.00133333333333333*G4_0_0 + 0.000666666666666666*G4_0_1 + 0.000666666666666666*G4_1_0 + 0.00133333333333333*G4_1_1;
    A[141] = 0.0;
    A[142] = 0.0;
    A[143] = 0.0;
    A[144] = 0.0;
    A[145] = 0.0;
    A[146] = 0.0;
    A[147] = -0.166666666666667*G6_0 + 0.166666666666667*G6_1;
    A[148] = 0.166666666666666*G6_0 + 0.333333333333333*G6_1;
    A[149] = 0.166666666666667*G6_1;
    A[150] = 0.0;
    A[151] = 0.0;
    A[152] = 0.0;
    A[153] = 0.0;
    A[154] = 0.0;
    A[155] = 0.0;
    A[156] = 0.0;
    A[157] = 0.0;
    A[158] = 0.0;
    A[159] = 0.0;
    A[160] = 0.0;
    A[161] = 0.0;
    A[162] = 0.0;
    A[163] = 0.0;
    A[164] = 0.0;
    A[165] = 0.0;
    A[166] = 0.0;
    A[167] = 0.0;
    A[168] = 0.000499999999999999*G3_0_0 + 0.0005*G3_0_1 + 0.0005*G3_1_0 + 0.0005*G3_1_1 + 0.000499999999999999*G5_0_0 + 0.0005*G5_0_1 + 0.0005*G5_1_0 + 0.0005*G5_1_1;
    A[169] = 0.000166666666666666*G3_0_0 + 0.000166666666666667*G3_1_0 + 0.000166666666666666*G5_0_0 + 0.000166666666666667*G5_1_0;
    A[170] = 0.000166666666666666*G3_0_1 + 0.000166666666666666*G3_1_1 + 0.000166666666666666*G5_0_1 + 0.000166666666666666*G5_1_1;
    A[171] = 0.0;
    A[172] = -0.000666666666666666*G3_0_1 - 0.000666666666666666*G3_1_1 - 0.000666666666666666*G5_0_1 - 0.000666666666666666*G5_1_1;
    A[173] = -0.000666666666666666*G3_0_0 - 0.000666666666666666*G3_1_0 - 0.000666666666666666*G5_0_0 - 0.000666666666666666*G5_1_0;
    A[174] = 0.166666666666667*G7_0 + 0.166666666666667*G7_1;
    A[175] = 0.0;
    A[176] = 0.0;
    A[177] = 0.0;
    A[178] = 0.0;
    A[179] = 0.0;
    A[180] = 0.0;
    A[181] = 0.0;
    A[182] = 0.0;
    A[183] = 0.0;
    A[184] = 0.0;
    A[185] = 0.0;
    A[186] = 0.0;
    A[187] = 0.0;
    A[188] = 0.0;
    A[189] = 0.0;
    A[190] = 0.0;
    A[191] = 0.0;
    A[192] = 0.0;
    A[193] = 0.0;
    A[194] = 0.0;
    A[195] = 0.000166666666666666*G3_0_0 + 0.000166666666666667*G3_0_1 + 0.000166666666666666*G5_0_0 + 0.000166666666666667*G5_0_1;
    A[196] = 0.000499999999999999*G3_0_0 + 0.000499999999999999*G5_0_0;
    A[197] = -0.000166666666666666*G3_0_1 - 0.000166666666666666*G5_0_1;
    A[198] = 0.000666666666666666*G3_0_1 + 0.000666666666666666*G5_0_1;
    A[199] = 0.0;
    A[200] = -0.000666666666666666*G3_0_0 - 0.000666666666666666*G3_0_1 - 0.000666666666666666*G5_0_0 - 0.000666666666666666*G5_0_1;
    A[201] = 0.0;
    A[202] = -0.166666666666666*G7_0;
    A[203] = 0.0;
    A[204] = 0.0;
    A[205] = 0.0;
    A[206] = 0.0;
    A[207] = 0.0;
    A[208] = 0.0;
    A[209] = 0.0;
    A[210] = 0.0;
    A[211] = 0.0;
    A[212] = 0.0;
    A[213] = 0.0;
    A[214] = 0.0;
    A[215] = 0.0;
    A[216] = 0.0;
    A[217] = 0.0;
    A[218] = 0.0;
    A[219] = 0.0;
    A[220] = 0.0;
    A[221] = 0.0;
    A[222] = 0.000166666666666666*G3_1_0 + 0.000166666666666666*G3_1_1 + 0.000166666666666666*G5_1_0 + 0.000166666666666666*G5_1_1;
    A[223] = -0.000166666666666666*G3_1_0 - 0.000166666666666666*G5_1_0;
    A[224] = 0.0005*G3_1_1 + 0.0005*G5_1_1;
    A[225] = 0.000666666666666666*G3_1_0 + 0.000666666666666666*G5_1_0;
    A[226] = -0.000666666666666666*G3_1_0 - 0.000666666666666666*G3_1_1 - 0.000666666666666666*G5_1_0 - 0.000666666666666666*G5_1_1;
    A[227] = 0.0;
    A[228] = 0.0;
    A[229] = 0.0;
    A[230] = -0.166666666666667*G7_1;
    A[231] = 0.0;
    A[232] = 0.0;
    A[233] = 0.0;
    A[234] = 0.0;
    A[235] = 0.0;
    A[236] = 0.0;
    A[237] = 0.0;
    A[238] = 0.0;
    A[239] = 0.0;
    A[240] = 0.0;
    A[241] = 0.0;
    A[242] = 0.0;
    A[243] = 0.0;
    A[244] = 0.0;
    A[245] = 0.0;
    A[246] = 0.0;
    A[247] = 0.0;
    A[248] = 0.0;
    A[249] = 0.0;
    A[250] = 0.000666666666666666*G3_1_0 + 0.000666666666666666*G5_1_0;
    A[251] = 0.000666666666666666*G3_0_1 + 0.000666666666666666*G5_0_1;
    A[252] = 0.00133333333333333*G3_0_0 + 0.000666666666666666*G3_0_1 + 0.000666666666666666*G3_1_0 + 0.00133333333333333*G3_1_1 + 0.00133333333333333*G5_0_0 + 0.000666666666666666*G5_0_1 + 0.000666666666666666*G5_1_0 + 0.00133333333333333*G5_1_1;
    A[253] = -0.00133333333333333*G3_0_0 - 0.000666666666666666*G3_0_1 - 0.000666666666666666*G3_1_0 - 0.00133333333333333*G5_0_0 - 0.000666666666666666*G5_0_1 - 0.000666666666666666*G5_1_0;
    A[254] = -0.000666666666666666*G3_0_1 - 0.000666666666666665*G3_1_0 - 0.00133333333333333*G3_1_1 - 0.000666666666666666*G5_0_1 - 0.000666666666666665*G5_1_0 - 0.00133333333333333*G5_1_1;
    A[255] = -0.166666666666667*G7_0 - 0.166666666666667*G7_1;
    A[256] = -0.166666666666667*G7_0 - 0.333333333333333*G7_1;
    A[257] = -0.333333333333333*G7_0 - 0.166666666666667*G7_1;
    A[258] = 0.0;
    A[259] = 0.0;
    A[260] = 0.0;
    A[261] = 0.0;
    A[262] = 0.0;
    A[263] = 0.0;
    A[264] = 0.0;
    A[265] = 0.0;
    A[266] = 0.0;
    A[267] = 0.0;
    A[268] = 0.0;
    A[269] = 0.0;
    A[270] = 0.0;
    A[271] = 0.0;
    A[272] = 0.0;
    A[273] = 0.0;
    A[274] = 0.0;
    A[275] = 0.0;
    A[276] = -0.000666666666666666*G3_1_0 - 0.000666666666666666*G3_1_1 - 0.000666666666666666*G5_1_0 - 0.000666666666666666*G5_1_1;
    A[277] = 0.0;
    A[278] = -0.000666666666666666*G3_0_1 - 0.000666666666666666*G3_1_1 - 0.000666666666666666*G5_0_1 - 0.000666666666666666*G5_1_1;
    A[279] = -0.00133333333333333*G3_0_0 - 0.000666666666666666*G3_0_1 - 0.000666666666666666*G3_1_0 - 0.00133333333333333*G5_0_0 - 0.000666666666666666*G5_0_1 - 0.000666666666666666*G5_1_0;
    A[280] = 0.00133333333333333*G3_0_0 + 0.000666666666666666*G3_0_1 + 0.000666666666666666*G3_1_0 + 0.00133333333333333*G3_1_1 + 0.00133333333333333*G5_0_0 + 0.000666666666666666*G5_0_1 + 0.000666666666666666*G5_1_0 + 0.00133333333333333*G5_1_1;
    A[281] = 0.000666666666666667*G3_0_1 + 0.000666666666666666*G3_1_0 + 0.000666666666666667*G5_0_1 + 0.000666666666666666*G5_1_0;
    A[282] = 0.166666666666667*G7_0 - 0.166666666666667*G7_1;
    A[283] = 0.166666666666667*G7_0;
    A[284] = 0.333333333333333*G7_0 + 0.166666666666666*G7_1;
    A[285] = 0.0;
    A[286] = 0.0;
    A[287] = 0.0;
    A[288] = 0.0;
    A[289] = 0.0;
    A[290] = 0.0;
    A[291] = 0.0;
    A[292] = 0.0;
    A[293] = 0.0;
    A[294] = 0.0;
    A[295] = 0.0;
    A[296] = 0.0;
    A[297] = 0.0;
    A[298] = 0.0;
    A[299] = 0.0;
    A[300] = 0.0;
    A[301] = 0.0;
    A[302] = 0.0;
    A[303] = -0.000666666666666666*G3_0_0 - 0.000666666666666666*G3_0_1 - 0.000666666666666666*G5_0_0 - 0.000666666666666666*G5_0_1;
    A[304] = -0.000666666666666666*G3_0_0 - 0.000666666666666666*G3_1_0 - 0.000666666666666666*G5_0_0 - 0.000666666666666666*G5_1_0;
    A[305] = 0.0;
    A[306] = -0.000666666666666666*G3_0_1 - 0.000666666666666666*G3_1_0 - 0.00133333333333333*G3_1_1 - 0.000666666666666666*G5_0_1 - 0.000666666666666666*G5_1_0 - 0.00133333333333333*G5_1_1;
    A[307] = 0.000666666666666666*G3_0_1 + 0.000666666666666667*G3_1_0 + 0.000666666666666666*G5_0_1 + 0.000666666666666667*G5_1_0;
    A[308] = 0.00133333333333333*G3_0_0 + 0.000666666666666666*G3_0_1 + 0.000666666666666666*G3_1_0 + 0.00133333333333333*G3_1_1 + 0.00133333333333333*G5_0_0 + 0.000666666666666666*G5_0_1 + 0.000666666666666666*G5_1_0 + 0.00133333333333333*G5_1_1;
    A[309] = -0.166666666666667*G7_0 + 0.166666666666667*G7_1;
    A[310] = 0.166666666666666*G7_0 + 0.333333333333333*G7_1;
    A[311] = 0.166666666666667*G7_1;
    A[312] = 0.0;
    A[313] = 0.0;
    A[314] = 0.0;
    A[315] = 0.0;
    A[316] = 0.0;
    A[317] = 0.0;
    A[318] = 0.0;
    A[319] = 0.0;
    A[320] = 0.0;
    A[321] = 0.0;
    A[322] = 0.0;
    A[323] = 0.0;
    A[324] = 0.166666666666667*G0_0 + 0.166666666666667*G0_1;
    A[325] = 0.0;
    A[326] = 0.0;
    A[327] = -0.166666666666667*G0_0 - 0.166666666666667*G0_1;
    A[328] = 0.166666666666667*G0_0 - 0.166666666666667*G0_1;
    A[329] = -0.166666666666667*G0_0 + 0.166666666666667*G0_1;
    A[330] = 0.166666666666667*G1_0 + 0.166666666666667*G1_1;
    A[331] = 0.0;
    A[332] = 0.0;
    A[333] = -0.166666666666667*G1_0 - 0.166666666666667*G1_1;
    A[334] = 0.166666666666667*G1_0 - 0.166666666666667*G1_1;
    A[335] = -0.166666666666667*G1_0 + 0.166666666666667*G1_1;
    A[336] = 0.0;
    A[337] = 0.0;
    A[338] = 0.0;
    A[339] = 0.0;
    A[340] = 0.0;
    A[341] = 0.0;
    A[342] = 0.0;
    A[343] = 0.0;
    A[344] = 0.0;
    A[345] = 0.0;
    A[346] = 0.0;
    A[347] = 0.0;
    A[348] = 0.0;
    A[349] = 0.0;
    A[350] = 0.0;
    A[351] = 0.0;
    A[352] = -0.166666666666666*G0_0;
    A[353] = 0.0;
    A[354] = -0.166666666666667*G0_0 - 0.333333333333333*G0_1;
    A[355] = 0.166666666666667*G0_0;
    A[356] = 0.166666666666666*G0_0 + 0.333333333333333*G0_1;
    A[357] = 0.0;
    A[358] = -0.166666666666666*G1_0;
    A[359] = 0.0;
    A[360] = -0.166666666666667*G1_0 - 0.333333333333333*G1_1;
    A[361] = 0.166666666666667*G1_0;
    A[362] = 0.166666666666666*G1_0 + 0.333333333333333*G1_1;
    A[363] = 0.0;
    A[364] = 0.0;
    A[365] = 0.0;
    A[366] = 0.0;
    A[367] = 0.0;
    A[368] = 0.0;
    A[369] = 0.0;
    A[370] = 0.0;
    A[371] = 0.0;
    A[372] = 0.0;
    A[373] = 0.0;
    A[374] = 0.0;
    A[375] = 0.0;
    A[376] = 0.0;
    A[377] = 0.0;
    A[378] = 0.0;
    A[379] = 0.0;
    A[380] = -0.166666666666667*G0_1;
    A[381] = -0.333333333333333*G0_0 - 0.166666666666667*G0_1;
    A[382] = 0.333333333333333*G0_0 + 0.166666666666666*G0_1;
    A[383] = 0.166666666666667*G0_1;
    A[384] = 0.0;
    A[385] = 0.0;
    A[386] = -0.166666666666667*G1_1;
    A[387] = -0.333333333333333*G1_0 - 0.166666666666667*G1_1;
    A[388] = 0.333333333333333*G1_0 + 0.166666666666666*G1_1;
    A[389] = 0.166666666666667*G1_1;
    A[390] = 0.0;
    A[391] = 0.0;
    A[392] = 0.0;
    A[393] = 0.0;
    A[394] = 0.0;
    A[395] = 0.0;
    A[396] = 0.0;
    A[397] = 0.0;
    A[398] = 0.0;
    A[399] = 0.0;
    A[400] = 0.0;
    A[401] = 0.0;
    A[402] = 0.0;
    A[403] = 0.0;
    A[404] = 0.0;
    A[405] = 0.0;
    A[406] = 0.0;
    A[407] = 0.0;
    A[408] = 0.0;
    A[409] = 0.0;
    A[410] = 0.0;
    A[411] = 0.0;
    A[412] = 0.0;
    A[413] = 0.0;
    A[414] = 0.0;
    A[415] = 0.0;
    A[416] = 0.0;
    A[417] = 0.0;
    A[418] = 0.0;
    A[419] = 0.0;
    A[420] = 0.0;
    A[421] = 0.0;
    A[422] = 0.0;
    A[423] = 0.0;
    A[424] = 0.0;
    A[425] = 0.0;
    A[426] = 0.0;
    A[427] = 0.0;
    A[428] = 0.0;
    A[429] = 0.0;
    A[430] = 0.0;
    A[431] = 0.0;
    A[432] = 0.0;
    A[433] = 0.0;
    A[434] = 0.0;
    A[435] = 0.0;
    A[436] = 0.0;
    A[437] = 0.0;
    A[438] = 0.0;
    A[439] = 0.0;
    A[440] = 0.0;
    A[441] = 0.0;
    A[442] = 0.0;
    A[443] = 0.0;
    A[444] = 0.0;
    A[445] = 0.0;
    A[446] = 0.0;
    A[447] = 0.0;
    A[448] = 0.0;
    A[449] = 0.0;
    A[450] = 0.0;
    A[451] = 0.0;
    A[452] = 0.0;
    A[453] = 0.0;
    A[454] = 0.0;
    A[455] = 0.0;
    A[456] = 0.0;
    A[457] = 0.0;
    A[458] = 0.0;
    A[459] = 0.0;
    A[460] = 0.0;
    A[461] = 0.0;
    A[462] = 0.0;
    A[463] = 0.0;
    A[464] = 0.0;
    A[465] = 0.0;
    A[466] = 0.0;
    A[467] = 0.0;
    A[468] = 0.0;
    A[469] = 0.0;
    A[470] = 0.0;
    A[471] = 0.0;
    A[472] = 0.0;
    A[473] = 0.0;
    A[474] = 0.0;
    A[475] = 0.0;
    A[476] = 0.0;
    A[477] = 0.0;
    A[478] = 0.0;
    A[479] = 0.0;
    A[480] = 0.0;
    A[481] = 0.0;
    A[482] = 0.0;
    A[483] = 0.0;
    A[484] = 0.0;
    A[485] = 0.0;
    A[486] = 0.0;
    A[487] = 0.0;
    A[488] = 0.0;
    A[489] = 0.0;
    A[490] = 0.0;
    A[491] = 0.0;
    A[492] = 0.0;
    A[493] = 0.0;
    A[494] = 0.0;
    A[495] = 0.0;
    A[496] = 0.0;
    A[497] = 0.0;
    A[498] = 0.0;
    A[499] = 0.0;
    A[500] = 0.0;
    A[501] = 0.0;
    A[502] = 0.0;
    A[503] = 0.0;
    A[504] = 0.0;
    A[505] = 0.0;
    A[506] = 0.0;
    A[507] = 0.0;
    A[508] = 0.0;
    A[509] = 0.0;
    A[510] = 0.0;
    A[511] = 0.0;
    A[512] = 0.0;
    A[513] = 0.0;
    A[514] = 0.0;
    A[515] = 0.0;
    A[516] = 0.0;
    A[517] = 0.0;
    A[518] = 0.0;
    A[519] = 0.0;
    A[520] = 0.0;
    A[521] = 0.0;
    A[522] = 0.0;
    A[523] = 0.0;
    A[524] = 0.0;
    A[525] = 0.0;
    A[526] = 0.0;
    A[527] = 0.0;
    A[528] = 0.0;
    A[529] = 0.0;
    A[530] = 0.0;
    A[531] = 0.0;
    A[532] = 0.0;
    A[533] = 0.0;
    A[534] = 0.0;
    A[535] = 0.0;
    A[536] = 0.0;
    A[537] = 0.0;
    A[538] = 0.0;
    A[539] = 0.0;
    A[540] = 0.0;
    A[541] = 0.0;
    A[542] = 0.0;
    A[543] = 0.0;
    A[544] = 0.0;
    A[545] = 0.0;
    A[546] = 0.0;
    A[547] = 0.0;
    A[548] = 0.0;
    A[549] = 0.0;
    A[550] = 0.0;
    A[551] = 0.0;
    A[552] = 0.0;
    A[553] = 0.0;
    A[554] = 0.0;
    A[555] = 0.0;
    A[556] = 0.0;
    A[557] = 0.0;
    A[558] = 0.0;
    A[559] = 0.0;
    A[560] = 0.0;
    A[561] = 0.0;
    A[562] = 0.0;
    A[563] = 0.0;
    A[564] = 0.0;
    A[565] = 0.0;
    A[566] = 0.0;
    A[567] = 0.0;
    A[568] = 0.0;
    A[569] = 0.0;
    A[570] = 0.0;
    A[571] = 0.0;
    A[572] = 0.0;
    A[573] = 0.0;
    A[574] = 0.0;
    A[575] = 0.0;
    A[576] = 0.0;
    A[577] = 0.0;
    A[578] = 0.0;
    A[579] = 0.0;
    A[580] = 0.0;
    A[581] = 0.0;
    A[582] = 0.0;
    A[583] = 0.0;
    A[584] = 0.0;
    A[585] = 0.0;
    A[586] = 0.0;
    A[587] = 0.0;
    A[588] = 0.0;
    A[589] = 0.0;
    A[590] = 0.0;
    A[591] = 0.0;
    A[592] = 0.0;
    A[593] = 0.0;
    A[594] = 0.0;
    A[595] = 0.0;
    A[596] = 0.0;
    A[597] = 0.0;
    A[598] = 0.0;
    A[599] = 0.0;
    A[600] = 0.0;
    A[601] = 0.0;
    A[602] = 0.0;
    A[603] = 0.0;
    A[604] = 0.0;
    A[605] = 0.0;
    A[606] = 0.0;
    A[607] = 0.0;
    A[608] = 0.0;
    A[609] = 0.0;
    A[610] = 0.0;
    A[611] = 0.0;
    A[612] = 0.0;
    A[613] = 0.0;
    A[614] = 0.0;
    A[615] = 0.0;
    A[616] = 0.0;
    A[617] = 0.0;
    A[618] = 0.0;
    A[619] = 0.0;
    A[620] = 0.0;
    A[621] = 0.0;
    A[622] = 0.0;
    A[623] = 0.0;
    A[624] = 0.0;
    A[625] = 0.0;
    A[626] = 0.0;
    A[627] = 0.0;
    A[628] = 0.0;
    A[629] = 0.0;
    A[630] = 0.0;
    A[631] = 0.0;
    A[632] = 0.0;
    A[633] = 0.0;
    A[634] = 0.0;
    A[635] = 0.0;
    A[636] = 0.0;
    A[637] = 0.0;
    A[638] = 0.0;
    A[639] = 0.0;
    A[640] = 0.0;
    A[641] = 0.0;
    A[642] = 0.0;
    A[643] = 0.0;
    A[644] = 0.0;
    A[645] = 0.0;
    A[646] = 0.0;
    A[647] = 0.0;
    A[648] = 0.0;
    A[649] = 0.0;
    A[650] = 0.0;
    A[651] = 0.0;
    A[652] = 0.0;
    A[653] = 0.0;
    A[654] = 0.0;
    A[655] = 0.0;
    A[656] = 0.0;
    A[657] = 0.0;
    A[658] = 0.0;
    A[659] = 0.0;
    A[660] = 0.0;
    A[661] = 0.0;
    A[662] = 0.0;
    A[663] = 0.0;
    A[664] = 0.0;
    A[665] = 0.0;
    A[666] = 0.0;
    A[667] = 0.0;
    A[668] = 0.0;
    A[669] = 0.0;
    A[670] = 0.0;
    A[671] = 0.0;
    A[672] = 0.0;
    A[673] = 0.0;
    A[674] = 0.0;
    A[675] = 0.0;
    A[676] = 0.0;
    A[677] = 0.0;
    A[678] = 0.0;
    A[679] = 0.0;
    A[680] = 0.0;
    A[681] = 0.0;
    A[682] = 0.0;
    A[683] = 0.0;
    A[684] = 0.0;
    A[685] = 0.0;
    A[686] = 0.0;
    A[687] = 0.0;
    A[688] = 0.0;
    A[689] = 0.0;
    A[690] = 0.0;
    A[691] = 0.0;
    A[692] = 0.0;
    A[693] = 0.0;
    A[694] = 0.0;
    A[695] = 0.0;
    A[696] = 0.0;
    A[697] = 0.0;
    A[698] = 0.0;
    A[699] = 0.0;
    A[700] = 0.0;
    A[701] = 0.0;
    A[702] = 0.0;
    A[703] = 0.0;
    A[704] = 0.0;
    A[705] = 0.0;
    A[706] = 0.0;
    A[707] = 0.0;
    A[708] = 0.0;
    A[709] = 0.0;
    A[710] = 0.0;
    A[711] = 0.0;
    A[712] = 0.0;
    A[713] = 0.0;
    A[714] = 0.0;
    A[715] = 0.0;
    A[716] = 0.0;
    A[717] = 0.0;
    A[718] = 0.0;
    A[719] = 0.0;
    A[720] = 0.0;
    A[721] = 0.0;
    A[722] = 0.0;
    A[723] = 0.0;
    A[724] = 0.0;
    A[725] = 0.0;
    A[726] = 0.0;
    A[727] = 0.0;
    A[728] = 0.0;
  }

  /// Tabulate the tensor for the contribution from a local cell
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not available when using the FFC tensor representation.");
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_exterior_facet_integral_0_0: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_exterior_facet_integral_0_0() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_exterior_facet_integral_0_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int facet) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      9
    // Number of operations (multiply-add pairs) for geometry tensor:    0
    // Number of operations (multiply-add pairs) for tensor contraction: 27
    // Total number of operations (multiply-add pairs):                  36
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = x[v1][0] - x[v0][0];
    const double dx1 = x[v1][1] - x[v0][1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    // Compute geometry tensor
    const double G0_ = det;
    const double G1_ = det;
    
    // Compute element tensor
    switch (facet)
    {
    case 0:
      {
        A[0] = 0.0;
      A[1] = 0.0;
      A[2] = 0.0;
      A[3] = 0.0;
      A[4] = 0.0;
      A[5] = 0.0;
      A[6] = 0.0;
      A[7] = 0.0;
      A[8] = 0.0;
      A[9] = 0.0;
      A[10] = 0.0;
      A[11] = 0.0;
      A[12] = 0.0;
      A[13] = 0.0;
      A[14] = 0.0;
      A[15] = 0.0;
      A[16] = 0.0;
      A[17] = 0.0;
      A[18] = 0.0;
      A[19] = 0.0;
      A[20] = 0.0;
      A[21] = 0.0;
      A[22] = 0.0;
      A[23] = 0.0;
      A[24] = 0.0;
      A[25] = 0.0;
      A[26] = 0.0;
      A[27] = 0.0;
      A[28] = 0.0;
      A[29] = 0.0;
      A[30] = 0.0;
      A[31] = 0.0;
      A[32] = 0.0;
      A[33] = 0.0;
      A[34] = 0.0;
      A[35] = 0.0;
      A[36] = 0.0;
      A[37] = 0.0;
      A[38] = 0.0;
      A[39] = 0.0;
      A[40] = 0.0;
      A[41] = 0.0;
      A[42] = 0.0;
      A[43] = 0.0;
      A[44] = 0.0;
      A[45] = 0.0;
      A[46] = 0.0;
      A[47] = 0.0;
      A[48] = 0.0;
      A[49] = 0.0;
      A[50] = 0.0;
      A[51] = 0.0;
      A[52] = 0.0;
      A[53] = 0.0;
      A[54] = 0.0;
      A[55] = 0.0;
      A[56] = 0.0;
      A[57] = 0.0;
      A[58] = 0.0;
      A[59] = 0.0;
      A[60] = 0.0;
      A[61] = 0.0;
      A[62] = 0.0;
      A[63] = 0.0;
      A[64] = 0.0;
      A[65] = 0.0;
      A[66] = 0.0;
      A[67] = 0.0;
      A[68] = 0.0;
      A[69] = 0.0;
      A[70] = 0.0;
      A[71] = 0.0;
      A[72] = 0.0;
      A[73] = 0.0;
      A[74] = 0.0;
      A[75] = 0.0;
      A[76] = 0.0;
      A[77] = 0.0;
      A[78] = 0.0;
      A[79] = 0.0;
      A[80] = 0.0;
      A[81] = 0.0;
      A[82] = 0.0;
      A[83] = 0.0;
      A[84] = 0.0;
      A[85] = 0.0;
      A[86] = 0.0;
      A[87] = 0.0;
      A[88] = 0.0;
      A[89] = 0.0;
      A[90] = 0.0;
      A[91] = 0.0;
      A[92] = 0.0;
      A[93] = 0.0;
      A[94] = 0.0;
      A[95] = 0.0;
      A[96] = 0.0;
      A[97] = 0.0;
      A[98] = 0.0;
      A[99] = 0.0;
      A[100] = 0.0;
      A[101] = 0.0;
      A[102] = 0.0;
      A[103] = 0.0;
      A[104] = 0.0;
      A[105] = 0.0;
      A[106] = 0.0;
      A[107] = 0.0;
      A[108] = 0.0;
      A[109] = 0.0;
      A[110] = 0.0;
      A[111] = 0.0;
      A[112] = 0.0;
      A[113] = 0.0;
      A[114] = 0.0;
      A[115] = 0.0;
      A[116] = 0.0;
      A[117] = 0.0;
      A[118] = 0.0;
      A[119] = 0.0;
      A[120] = 0.0;
      A[121] = 0.0;
      A[122] = 0.0;
      A[123] = 0.0;
      A[124] = 0.0;
      A[125] = 0.0;
      A[126] = 0.0;
      A[127] = 0.0;
      A[128] = 0.0;
      A[129] = 0.0;
      A[130] = 0.0;
      A[131] = 0.0;
      A[132] = 0.0;
      A[133] = 0.0;
      A[134] = 0.0;
      A[135] = 0.0;
      A[136] = 0.0;
      A[137] = 0.0;
      A[138] = 0.0;
      A[139] = 0.0;
      A[140] = 0.0;
      A[141] = 0.0;
      A[142] = 0.0;
      A[143] = 0.0;
      A[144] = 0.0;
      A[145] = 0.0;
      A[146] = 0.0;
      A[147] = 0.0;
      A[148] = 0.0;
      A[149] = 0.0;
      A[150] = 0.0;
      A[151] = 0.0;
      A[152] = 0.0;
      A[153] = 0.0;
      A[154] = 0.0;
      A[155] = 0.0;
      A[156] = 0.0;
      A[157] = 0.0;
      A[158] = 0.0;
      A[159] = 0.0;
      A[160] = 0.0;
      A[161] = 0.0;
      A[162] = 0.0;
      A[163] = 0.0;
      A[164] = 0.0;
      A[165] = 0.0;
      A[166] = 0.0;
      A[167] = 0.0;
      A[168] = 0.0;
      A[169] = 0.0;
      A[170] = 0.0;
      A[171] = 0.0;
      A[172] = 0.0;
      A[173] = 0.0;
      A[174] = 0.0;
      A[175] = 0.0;
      A[176] = 0.0;
      A[177] = 0.0;
      A[178] = 0.0;
      A[179] = 0.0;
      A[180] = 0.0;
      A[181] = 0.0;
      A[182] = 0.0;
      A[183] = 0.0;
      A[184] = 0.0;
      A[185] = 0.0;
      A[186] = 0.0;
      A[187] = 0.0;
      A[188] = 0.0;
      A[189] = 0.0;
      A[190] = 0.0;
      A[191] = 0.0;
      A[192] = 0.0;
      A[193] = 0.0;
      A[194] = 0.0;
      A[195] = 0.0;
      A[196] = 0.0;
      A[197] = 0.0;
      A[198] = 0.0;
      A[199] = 0.0;
      A[200] = 0.0;
      A[201] = 0.0;
      A[202] = 0.0;
      A[203] = 0.0;
      A[204] = 0.0;
      A[205] = 0.0;
      A[206] = 0.0;
      A[207] = 0.0;
      A[208] = 0.0;
      A[209] = 0.0;
      A[210] = 0.0;
      A[211] = 0.0;
      A[212] = 0.0;
      A[213] = 0.0;
      A[214] = 0.0;
      A[215] = 0.0;
      A[216] = 0.0;
      A[217] = 0.0;
      A[218] = 0.0;
      A[219] = 0.0;
      A[220] = 0.0;
      A[221] = 0.0;
      A[222] = 0.0;
      A[223] = 0.0;
      A[224] = 0.0;
      A[225] = 0.0;
      A[226] = 0.0;
      A[227] = 0.0;
      A[228] = 0.0;
      A[229] = 0.0;
      A[230] = 0.0;
      A[231] = 0.0;
      A[232] = 0.0;
      A[233] = 0.0;
      A[234] = 0.0;
      A[235] = 0.0;
      A[236] = 0.0;
      A[237] = 0.0;
      A[238] = 0.0;
      A[239] = 0.0;
      A[240] = 0.0;
      A[241] = 0.0;
      A[242] = 0.0;
      A[243] = 0.0;
      A[244] = 0.0;
      A[245] = 0.0;
      A[246] = 0.0;
      A[247] = 0.0;
      A[248] = 0.0;
      A[249] = 0.0;
      A[250] = 0.0;
      A[251] = 0.0;
      A[252] = 0.0;
      A[253] = 0.0;
      A[254] = 0.0;
      A[255] = 0.0;
      A[256] = 0.0;
      A[257] = 0.0;
      A[258] = 0.0;
      A[259] = 0.0;
      A[260] = 0.0;
      A[261] = 0.0;
      A[262] = 0.0;
      A[263] = 0.0;
      A[264] = 0.0;
      A[265] = 0.0;
      A[266] = 0.0;
      A[267] = 0.0;
      A[268] = 0.0;
      A[269] = 0.0;
      A[270] = 0.0;
      A[271] = 0.0;
      A[272] = 0.0;
      A[273] = 0.0;
      A[274] = 0.0;
      A[275] = 0.0;
      A[276] = 0.0;
      A[277] = 0.0;
      A[278] = 0.0;
      A[279] = 0.0;
      A[280] = 0.0;
      A[281] = 0.0;
      A[282] = 0.0;
      A[283] = 0.0;
      A[284] = 0.0;
      A[285] = 0.0;
      A[286] = 0.0;
      A[287] = 0.0;
      A[288] = 0.0;
      A[289] = 0.0;
      A[290] = 0.0;
      A[291] = 0.0;
      A[292] = 0.0;
      A[293] = 0.0;
      A[294] = 0.0;
      A[295] = 0.0;
      A[296] = 0.0;
      A[297] = 0.0;
      A[298] = 0.0;
      A[299] = 0.0;
      A[300] = 0.0;
      A[301] = 0.0;
      A[302] = 0.0;
      A[303] = 0.0;
      A[304] = 0.0;
      A[305] = 0.0;
      A[306] = 0.0;
      A[307] = 0.0;
      A[308] = 0.0;
      A[309] = 0.0;
      A[310] = 0.0;
      A[311] = 0.0;
      A[312] = 0.0;
      A[313] = 0.0;
      A[314] = 0.0;
      A[315] = 0.0;
      A[316] = 0.0;
      A[317] = 0.0;
      A[318] = 0.0;
      A[319] = 0.0;
      A[320] = 0.0;
      A[321] = 0.0;
      A[322] = 0.0;
      A[323] = 0.0;
      A[324] = 0.0;
      A[325] = 0.0;
      A[326] = 0.0;
      A[327] = 0.0;
      A[328] = 0.0;
      A[329] = 0.0;
      A[330] = 0.0;
      A[331] = 0.0;
      A[332] = 0.0;
      A[333] = 0.0;
      A[334] = 0.0;
      A[335] = 0.0;
      A[336] = 0.0;
      A[337] = 0.0;
      A[338] = 0.0;
      A[339] = 0.0;
      A[340] = 0.0;
      A[341] = 0.0;
      A[342] = 0.0;
      A[343] = 0.0;
      A[344] = 0.0;
      A[345] = 0.0;
      A[346] = 0.0;
      A[347] = 0.0;
      A[348] = 0.0;
      A[349] = 0.0;
      A[350] = 0.0;
      A[351] = 0.0;
      A[352] = 0.0;
      A[353] = 0.0;
      A[354] = 0.0;
      A[355] = 0.0;
      A[356] = 0.0;
      A[357] = 0.0;
      A[358] = 0.0;
      A[359] = 0.0;
      A[360] = 0.0;
      A[361] = 0.0;
      A[362] = 0.0;
      A[363] = 0.0;
      A[364] = 0.0;
      A[365] = 0.0;
      A[366] = 0.0;
      A[367] = 0.0;
      A[368] = 0.0;
      A[369] = 0.0;
      A[370] = 0.0;
      A[371] = 0.0;
      A[372] = 0.0;
      A[373] = 0.0;
      A[374] = 0.0;
      A[375] = 0.0;
      A[376] = 0.0;
      A[377] = 0.0;
      A[378] = 0.0;
      A[379] = 0.0;
      A[380] = 0.0;
      A[381] = 0.0;
      A[382] = 0.0;
      A[383] = 0.0;
      A[384] = 0.0;
      A[385] = 0.0;
      A[386] = 0.0;
      A[387] = 0.0;
      A[388] = 0.0;
      A[389] = 0.0;
      A[390] = 0.0;
      A[391] = 0.0;
      A[392] = 0.0;
      A[393] = 0.0;
      A[394] = 0.0;
      A[395] = 0.0;
      A[396] = 0.0;
      A[397] = 0.0;
      A[398] = 0.0;
      A[399] = 0.0;
      A[400] = 0.0;
      A[401] = 0.0;
      A[402] = 0.0;
      A[403] = 0.0;
      A[404] = 0.0;
      A[405] = 0.0;
      A[406] = 0.0;
      A[407] = 0.0;
      A[408] = 0.0;
      A[409] = 0.0;
      A[410] = 0.0;
      A[411] = 0.0;
      A[412] = 0.0;
      A[413] = 0.0;
      A[414] = 0.0;
      A[415] = 0.0;
      A[416] = 0.0;
      A[417] = 0.0;
      A[418] = 0.0;
      A[419] = 0.0;
      A[420] = 0.0;
      A[421] = 0.0;
      A[422] = 0.0;
      A[423] = 0.0;
      A[424] = 0.0;
      A[425] = 0.0;
      A[426] = 0.0;
      A[427] = 0.0;
      A[428] = 0.0;
      A[429] = 0.0;
      A[430] = 0.0;
      A[431] = 0.0;
      A[432] = 0.0;
      A[433] = 0.133333333333333*G0_;
      A[434] = -0.0333333333333333*G0_;
      A[435] = 0.0666666666666666*G0_;
      A[436] = 0.0;
      A[437] = 0.0;
      A[438] = 0.0;
      A[439] = 0.0;
      A[440] = 0.0;
      A[441] = 0.0;
      A[442] = 0.0;
      A[443] = 0.0;
      A[444] = 0.0;
      A[445] = 0.0;
      A[446] = 0.0;
      A[447] = 0.0;
      A[448] = 0.0;
      A[449] = 0.0;
      A[450] = 0.0;
      A[451] = 0.0;
      A[452] = 0.0;
      A[453] = 0.0;
      A[454] = 0.0;
      A[455] = 0.0;
      A[456] = 0.0;
      A[457] = 0.0;
      A[458] = 0.0;
      A[459] = 0.0;
      A[460] = -0.0333333333333333*G0_;
      A[461] = 0.133333333333333*G0_;
      A[462] = 0.0666666666666666*G0_;
      A[463] = 0.0;
      A[464] = 0.0;
      A[465] = 0.0;
      A[466] = 0.0;
      A[467] = 0.0;
      A[468] = 0.0;
      A[469] = 0.0;
      A[470] = 0.0;
      A[471] = 0.0;
      A[472] = 0.0;
      A[473] = 0.0;
      A[474] = 0.0;
      A[475] = 0.0;
      A[476] = 0.0;
      A[477] = 0.0;
      A[478] = 0.0;
      A[479] = 0.0;
      A[480] = 0.0;
      A[481] = 0.0;
      A[482] = 0.0;
      A[483] = 0.0;
      A[484] = 0.0;
      A[485] = 0.0;
      A[486] = 0.0;
      A[487] = 0.0666666666666666*G0_;
      A[488] = 0.0666666666666666*G0_;
      A[489] = 0.533333333333333*G0_;
      A[490] = 0.0;
      A[491] = 0.0;
      A[492] = 0.0;
      A[493] = 0.0;
      A[494] = 0.0;
      A[495] = 0.0;
      A[496] = 0.0;
      A[497] = 0.0;
      A[498] = 0.0;
      A[499] = 0.0;
      A[500] = 0.0;
      A[501] = 0.0;
      A[502] = 0.0;
      A[503] = 0.0;
      A[504] = 0.0;
      A[505] = 0.0;
      A[506] = 0.0;
      A[507] = 0.0;
      A[508] = 0.0;
      A[509] = 0.0;
      A[510] = 0.0;
      A[511] = 0.0;
      A[512] = 0.0;
      A[513] = 0.0;
      A[514] = 0.0;
      A[515] = 0.0;
      A[516] = 0.0;
      A[517] = 0.0;
      A[518] = 0.0;
      A[519] = 0.0;
      A[520] = 0.0;
      A[521] = 0.0;
      A[522] = 0.0;
      A[523] = 0.0;
      A[524] = 0.0;
      A[525] = 0.0;
      A[526] = 0.0;
      A[527] = 0.0;
      A[528] = 0.0;
      A[529] = 0.0;
      A[530] = 0.0;
      A[531] = 0.0;
      A[532] = 0.0;
      A[533] = 0.0;
      A[534] = 0.0;
      A[535] = 0.0;
      A[536] = 0.0;
      A[537] = 0.0;
      A[538] = 0.0;
      A[539] = 0.0;
      A[540] = 0.0;
      A[541] = 0.0;
      A[542] = 0.0;
      A[543] = 0.0;
      A[544] = 0.0;
      A[545] = 0.0;
      A[546] = 0.0;
      A[547] = 0.0;
      A[548] = 0.0;
      A[549] = 0.0;
      A[550] = 0.0;
      A[551] = 0.0;
      A[552] = 0.0;
      A[553] = 0.0;
      A[554] = 0.0;
      A[555] = 0.0;
      A[556] = 0.0;
      A[557] = 0.0;
      A[558] = 0.0;
      A[559] = 0.0;
      A[560] = 0.0;
      A[561] = 0.0;
      A[562] = 0.0;
      A[563] = 0.0;
      A[564] = 0.0;
      A[565] = 0.0;
      A[566] = 0.0;
      A[567] = 0.0;
      A[568] = 0.0;
      A[569] = 0.0;
      A[570] = 0.0;
      A[571] = 0.0;
      A[572] = 0.0;
      A[573] = 0.0;
      A[574] = 0.0;
      A[575] = 0.0;
      A[576] = 0.0;
      A[577] = 0.0;
      A[578] = 0.0;
      A[579] = 0.0;
      A[580] = 0.0;
      A[581] = 0.0;
      A[582] = 0.0;
      A[583] = 0.0;
      A[584] = 0.0;
      A[585] = 0.0;
      A[586] = 0.0;
      A[587] = 0.0;
      A[588] = 0.0;
      A[589] = 0.0;
      A[590] = 0.0;
      A[591] = 0.0;
      A[592] = 0.0;
      A[593] = 0.0;
      A[594] = 0.0;
      A[595] = 0.0;
      A[596] = 0.0;
      A[597] = 0.0;
      A[598] = 0.0;
      A[599] = 0.0;
      A[600] = 0.0;
      A[601] = 0.133333333333333*G1_;
      A[602] = -0.0333333333333333*G1_;
      A[603] = 0.0666666666666666*G1_;
      A[604] = 0.0;
      A[605] = 0.0;
      A[606] = 0.0;
      A[607] = 0.0;
      A[608] = 0.0;
      A[609] = 0.0;
      A[610] = 0.0;
      A[611] = 0.0;
      A[612] = 0.0;
      A[613] = 0.0;
      A[614] = 0.0;
      A[615] = 0.0;
      A[616] = 0.0;
      A[617] = 0.0;
      A[618] = 0.0;
      A[619] = 0.0;
      A[620] = 0.0;
      A[621] = 0.0;
      A[622] = 0.0;
      A[623] = 0.0;
      A[624] = 0.0;
      A[625] = 0.0;
      A[626] = 0.0;
      A[627] = 0.0;
      A[628] = -0.0333333333333333*G1_;
      A[629] = 0.133333333333333*G1_;
      A[630] = 0.0666666666666666*G1_;
      A[631] = 0.0;
      A[632] = 0.0;
      A[633] = 0.0;
      A[634] = 0.0;
      A[635] = 0.0;
      A[636] = 0.0;
      A[637] = 0.0;
      A[638] = 0.0;
      A[639] = 0.0;
      A[640] = 0.0;
      A[641] = 0.0;
      A[642] = 0.0;
      A[643] = 0.0;
      A[644] = 0.0;
      A[645] = 0.0;
      A[646] = 0.0;
      A[647] = 0.0;
      A[648] = 0.0;
      A[649] = 0.0;
      A[650] = 0.0;
      A[651] = 0.0;
      A[652] = 0.0;
      A[653] = 0.0;
      A[654] = 0.0;
      A[655] = 0.0666666666666666*G1_;
      A[656] = 0.0666666666666666*G1_;
      A[657] = 0.533333333333333*G1_;
      A[658] = 0.0;
      A[659] = 0.0;
      A[660] = 0.0;
      A[661] = 0.0;
      A[662] = 0.0;
      A[663] = 0.0;
      A[664] = 0.0;
      A[665] = 0.0;
      A[666] = 0.0;
      A[667] = 0.0;
      A[668] = 0.0;
      A[669] = 0.0;
      A[670] = 0.0;
      A[671] = 0.0;
      A[672] = 0.0;
      A[673] = 0.0;
      A[674] = 0.0;
      A[675] = 0.0;
      A[676] = 0.0;
      A[677] = 0.0;
      A[678] = 0.0;
      A[679] = 0.0;
      A[680] = 0.0;
      A[681] = 0.0;
      A[682] = 0.0;
      A[683] = 0.0;
      A[684] = 0.0;
      A[685] = 0.0;
      A[686] = 0.0;
      A[687] = 0.0;
      A[688] = 0.0;
      A[689] = 0.0;
      A[690] = 0.0;
      A[691] = 0.0;
      A[692] = 0.0;
      A[693] = 0.0;
      A[694] = 0.0;
      A[695] = 0.0;
      A[696] = 0.0;
      A[697] = 0.0;
      A[698] = 0.0;
      A[699] = 0.0;
      A[700] = 0.0;
      A[701] = 0.0;
      A[702] = 0.0;
      A[703] = 0.0;
      A[704] = 0.0;
      A[705] = 0.0;
      A[706] = 0.0;
      A[707] = 0.0;
      A[708] = 0.0;
      A[709] = 0.0;
      A[710] = 0.0;
      A[711] = 0.0;
      A[712] = 0.0;
      A[713] = 0.0;
      A[714] = 0.0;
      A[715] = 0.0;
      A[716] = 0.0;
      A[717] = 0.0;
      A[718] = 0.0;
      A[719] = 0.0;
      A[720] = 0.0;
      A[721] = 0.0;
      A[722] = 0.0;
      A[723] = 0.0;
      A[724] = 0.0;
      A[725] = 0.0;
      A[726] = 0.0;
      A[727] = 0.0;
      A[728] = 0.0;
        break;
      }
    case 1:
      {
        A[0] = 0.0;
      A[1] = 0.0;
      A[2] = 0.0;
      A[3] = 0.0;
      A[4] = 0.0;
      A[5] = 0.0;
      A[6] = 0.0;
      A[7] = 0.0;
      A[8] = 0.0;
      A[9] = 0.0;
      A[10] = 0.0;
      A[11] = 0.0;
      A[12] = 0.0;
      A[13] = 0.0;
      A[14] = 0.0;
      A[15] = 0.0;
      A[16] = 0.0;
      A[17] = 0.0;
      A[18] = 0.0;
      A[19] = 0.0;
      A[20] = 0.0;
      A[21] = 0.0;
      A[22] = 0.0;
      A[23] = 0.0;
      A[24] = 0.0;
      A[25] = 0.0;
      A[26] = 0.0;
      A[27] = 0.0;
      A[28] = 0.0;
      A[29] = 0.0;
      A[30] = 0.0;
      A[31] = 0.0;
      A[32] = 0.0;
      A[33] = 0.0;
      A[34] = 0.0;
      A[35] = 0.0;
      A[36] = 0.0;
      A[37] = 0.0;
      A[38] = 0.0;
      A[39] = 0.0;
      A[40] = 0.0;
      A[41] = 0.0;
      A[42] = 0.0;
      A[43] = 0.0;
      A[44] = 0.0;
      A[45] = 0.0;
      A[46] = 0.0;
      A[47] = 0.0;
      A[48] = 0.0;
      A[49] = 0.0;
      A[50] = 0.0;
      A[51] = 0.0;
      A[52] = 0.0;
      A[53] = 0.0;
      A[54] = 0.0;
      A[55] = 0.0;
      A[56] = 0.0;
      A[57] = 0.0;
      A[58] = 0.0;
      A[59] = 0.0;
      A[60] = 0.0;
      A[61] = 0.0;
      A[62] = 0.0;
      A[63] = 0.0;
      A[64] = 0.0;
      A[65] = 0.0;
      A[66] = 0.0;
      A[67] = 0.0;
      A[68] = 0.0;
      A[69] = 0.0;
      A[70] = 0.0;
      A[71] = 0.0;
      A[72] = 0.0;
      A[73] = 0.0;
      A[74] = 0.0;
      A[75] = 0.0;
      A[76] = 0.0;
      A[77] = 0.0;
      A[78] = 0.0;
      A[79] = 0.0;
      A[80] = 0.0;
      A[81] = 0.0;
      A[82] = 0.0;
      A[83] = 0.0;
      A[84] = 0.0;
      A[85] = 0.0;
      A[86] = 0.0;
      A[87] = 0.0;
      A[88] = 0.0;
      A[89] = 0.0;
      A[90] = 0.0;
      A[91] = 0.0;
      A[92] = 0.0;
      A[93] = 0.0;
      A[94] = 0.0;
      A[95] = 0.0;
      A[96] = 0.0;
      A[97] = 0.0;
      A[98] = 0.0;
      A[99] = 0.0;
      A[100] = 0.0;
      A[101] = 0.0;
      A[102] = 0.0;
      A[103] = 0.0;
      A[104] = 0.0;
      A[105] = 0.0;
      A[106] = 0.0;
      A[107] = 0.0;
      A[108] = 0.0;
      A[109] = 0.0;
      A[110] = 0.0;
      A[111] = 0.0;
      A[112] = 0.0;
      A[113] = 0.0;
      A[114] = 0.0;
      A[115] = 0.0;
      A[116] = 0.0;
      A[117] = 0.0;
      A[118] = 0.0;
      A[119] = 0.0;
      A[120] = 0.0;
      A[121] = 0.0;
      A[122] = 0.0;
      A[123] = 0.0;
      A[124] = 0.0;
      A[125] = 0.0;
      A[126] = 0.0;
      A[127] = 0.0;
      A[128] = 0.0;
      A[129] = 0.0;
      A[130] = 0.0;
      A[131] = 0.0;
      A[132] = 0.0;
      A[133] = 0.0;
      A[134] = 0.0;
      A[135] = 0.0;
      A[136] = 0.0;
      A[137] = 0.0;
      A[138] = 0.0;
      A[139] = 0.0;
      A[140] = 0.0;
      A[141] = 0.0;
      A[142] = 0.0;
      A[143] = 0.0;
      A[144] = 0.0;
      A[145] = 0.0;
      A[146] = 0.0;
      A[147] = 0.0;
      A[148] = 0.0;
      A[149] = 0.0;
      A[150] = 0.0;
      A[151] = 0.0;
      A[152] = 0.0;
      A[153] = 0.0;
      A[154] = 0.0;
      A[155] = 0.0;
      A[156] = 0.0;
      A[157] = 0.0;
      A[158] = 0.0;
      A[159] = 0.0;
      A[160] = 0.0;
      A[161] = 0.0;
      A[162] = 0.0;
      A[163] = 0.0;
      A[164] = 0.0;
      A[165] = 0.0;
      A[166] = 0.0;
      A[167] = 0.0;
      A[168] = 0.0;
      A[169] = 0.0;
      A[170] = 0.0;
      A[171] = 0.0;
      A[172] = 0.0;
      A[173] = 0.0;
      A[174] = 0.0;
      A[175] = 0.0;
      A[176] = 0.0;
      A[177] = 0.0;
      A[178] = 0.0;
      A[179] = 0.0;
      A[180] = 0.0;
      A[181] = 0.0;
      A[182] = 0.0;
      A[183] = 0.0;
      A[184] = 0.0;
      A[185] = 0.0;
      A[186] = 0.0;
      A[187] = 0.0;
      A[188] = 0.0;
      A[189] = 0.0;
      A[190] = 0.0;
      A[191] = 0.0;
      A[192] = 0.0;
      A[193] = 0.0;
      A[194] = 0.0;
      A[195] = 0.0;
      A[196] = 0.0;
      A[197] = 0.0;
      A[198] = 0.0;
      A[199] = 0.0;
      A[200] = 0.0;
      A[201] = 0.0;
      A[202] = 0.0;
      A[203] = 0.0;
      A[204] = 0.0;
      A[205] = 0.0;
      A[206] = 0.0;
      A[207] = 0.0;
      A[208] = 0.0;
      A[209] = 0.0;
      A[210] = 0.0;
      A[211] = 0.0;
      A[212] = 0.0;
      A[213] = 0.0;
      A[214] = 0.0;
      A[215] = 0.0;
      A[216] = 0.0;
      A[217] = 0.0;
      A[218] = 0.0;
      A[219] = 0.0;
      A[220] = 0.0;
      A[221] = 0.0;
      A[222] = 0.0;
      A[223] = 0.0;
      A[224] = 0.0;
      A[225] = 0.0;
      A[226] = 0.0;
      A[227] = 0.0;
      A[228] = 0.0;
      A[229] = 0.0;
      A[230] = 0.0;
      A[231] = 0.0;
      A[232] = 0.0;
      A[233] = 0.0;
      A[234] = 0.0;
      A[235] = 0.0;
      A[236] = 0.0;
      A[237] = 0.0;
      A[238] = 0.0;
      A[239] = 0.0;
      A[240] = 0.0;
      A[241] = 0.0;
      A[242] = 0.0;
      A[243] = 0.0;
      A[244] = 0.0;
      A[245] = 0.0;
      A[246] = 0.0;
      A[247] = 0.0;
      A[248] = 0.0;
      A[249] = 0.0;
      A[250] = 0.0;
      A[251] = 0.0;
      A[252] = 0.0;
      A[253] = 0.0;
      A[254] = 0.0;
      A[255] = 0.0;
      A[256] = 0.0;
      A[257] = 0.0;
      A[258] = 0.0;
      A[259] = 0.0;
      A[260] = 0.0;
      A[261] = 0.0;
      A[262] = 0.0;
      A[263] = 0.0;
      A[264] = 0.0;
      A[265] = 0.0;
      A[266] = 0.0;
      A[267] = 0.0;
      A[268] = 0.0;
      A[269] = 0.0;
      A[270] = 0.0;
      A[271] = 0.0;
      A[272] = 0.0;
      A[273] = 0.0;
      A[274] = 0.0;
      A[275] = 0.0;
      A[276] = 0.0;
      A[277] = 0.0;
      A[278] = 0.0;
      A[279] = 0.0;
      A[280] = 0.0;
      A[281] = 0.0;
      A[282] = 0.0;
      A[283] = 0.0;
      A[284] = 0.0;
      A[285] = 0.0;
      A[286] = 0.0;
      A[287] = 0.0;
      A[288] = 0.0;
      A[289] = 0.0;
      A[290] = 0.0;
      A[291] = 0.0;
      A[292] = 0.0;
      A[293] = 0.0;
      A[294] = 0.0;
      A[295] = 0.0;
      A[296] = 0.0;
      A[297] = 0.0;
      A[298] = 0.0;
      A[299] = 0.0;
      A[300] = 0.0;
      A[301] = 0.0;
      A[302] = 0.0;
      A[303] = 0.0;
      A[304] = 0.0;
      A[305] = 0.0;
      A[306] = 0.0;
      A[307] = 0.0;
      A[308] = 0.0;
      A[309] = 0.0;
      A[310] = 0.0;
      A[311] = 0.0;
      A[312] = 0.0;
      A[313] = 0.0;
      A[314] = 0.0;
      A[315] = 0.0;
      A[316] = 0.0;
      A[317] = 0.0;
      A[318] = 0.0;
      A[319] = 0.0;
      A[320] = 0.0;
      A[321] = 0.0;
      A[322] = 0.0;
      A[323] = 0.0;
      A[324] = 0.0;
      A[325] = 0.0;
      A[326] = 0.0;
      A[327] = 0.0;
      A[328] = 0.0;
      A[329] = 0.0;
      A[330] = 0.0;
      A[331] = 0.0;
      A[332] = 0.0;
      A[333] = 0.0;
      A[334] = 0.0;
      A[335] = 0.0;
      A[336] = 0.0;
      A[337] = 0.0;
      A[338] = 0.0;
      A[339] = 0.0;
      A[340] = 0.0;
      A[341] = 0.0;
      A[342] = 0.0;
      A[343] = 0.0;
      A[344] = 0.0;
      A[345] = 0.0;
      A[346] = 0.0;
      A[347] = 0.0;
      A[348] = 0.0;
      A[349] = 0.0;
      A[350] = 0.0;
      A[351] = 0.0;
      A[352] = 0.0;
      A[353] = 0.0;
      A[354] = 0.0;
      A[355] = 0.0;
      A[356] = 0.0;
      A[357] = 0.0;
      A[358] = 0.0;
      A[359] = 0.0;
      A[360] = 0.0;
      A[361] = 0.0;
      A[362] = 0.0;
      A[363] = 0.0;
      A[364] = 0.0;
      A[365] = 0.0;
      A[366] = 0.0;
      A[367] = 0.0;
      A[368] = 0.0;
      A[369] = 0.0;
      A[370] = 0.0;
      A[371] = 0.0;
      A[372] = 0.0;
      A[373] = 0.0;
      A[374] = 0.0;
      A[375] = 0.0;
      A[376] = 0.0;
      A[377] = 0.0;
      A[378] = 0.0;
      A[379] = 0.0;
      A[380] = 0.0;
      A[381] = 0.0;
      A[382] = 0.0;
      A[383] = 0.0;
      A[384] = 0.0;
      A[385] = 0.0;
      A[386] = 0.0;
      A[387] = 0.0;
      A[388] = 0.0;
      A[389] = 0.0;
      A[390] = 0.0;
      A[391] = 0.0;
      A[392] = 0.0;
      A[393] = 0.0;
      A[394] = 0.0;
      A[395] = 0.0;
      A[396] = 0.0;
      A[397] = 0.0;
      A[398] = 0.0;
      A[399] = 0.0;
      A[400] = 0.0;
      A[401] = 0.0;
      A[402] = 0.0;
      A[403] = 0.0;
      A[404] = 0.0;
      A[405] = 0.133333333333333*G0_;
      A[406] = 0.0;
      A[407] = -0.0333333333333333*G0_;
      A[408] = 0.0;
      A[409] = 0.0666666666666666*G0_;
      A[410] = 0.0;
      A[411] = 0.0;
      A[412] = 0.0;
      A[413] = 0.0;
      A[414] = 0.0;
      A[415] = 0.0;
      A[416] = 0.0;
      A[417] = 0.0;
      A[418] = 0.0;
      A[419] = 0.0;
      A[420] = 0.0;
      A[421] = 0.0;
      A[422] = 0.0;
      A[423] = 0.0;
      A[424] = 0.0;
      A[425] = 0.0;
      A[426] = 0.0;
      A[427] = 0.0;
      A[428] = 0.0;
      A[429] = 0.0;
      A[430] = 0.0;
      A[431] = 0.0;
      A[432] = 0.0;
      A[433] = 0.0;
      A[434] = 0.0;
      A[435] = 0.0;
      A[436] = 0.0;
      A[437] = 0.0;
      A[438] = 0.0;
      A[439] = 0.0;
      A[440] = 0.0;
      A[441] = 0.0;
      A[442] = 0.0;
      A[443] = 0.0;
      A[444] = 0.0;
      A[445] = 0.0;
      A[446] = 0.0;
      A[447] = 0.0;
      A[448] = 0.0;
      A[449] = 0.0;
      A[450] = 0.0;
      A[451] = 0.0;
      A[452] = 0.0;
      A[453] = 0.0;
      A[454] = 0.0;
      A[455] = 0.0;
      A[456] = 0.0;
      A[457] = 0.0;
      A[458] = 0.0;
      A[459] = -0.0333333333333333*G0_;
      A[460] = 0.0;
      A[461] = 0.133333333333333*G0_;
      A[462] = 0.0;
      A[463] = 0.0666666666666666*G0_;
      A[464] = 0.0;
      A[465] = 0.0;
      A[466] = 0.0;
      A[467] = 0.0;
      A[468] = 0.0;
      A[469] = 0.0;
      A[470] = 0.0;
      A[471] = 0.0;
      A[472] = 0.0;
      A[473] = 0.0;
      A[474] = 0.0;
      A[475] = 0.0;
      A[476] = 0.0;
      A[477] = 0.0;
      A[478] = 0.0;
      A[479] = 0.0;
      A[480] = 0.0;
      A[481] = 0.0;
      A[482] = 0.0;
      A[483] = 0.0;
      A[484] = 0.0;
      A[485] = 0.0;
      A[486] = 0.0;
      A[487] = 0.0;
      A[488] = 0.0;
      A[489] = 0.0;
      A[490] = 0.0;
      A[491] = 0.0;
      A[492] = 0.0;
      A[493] = 0.0;
      A[494] = 0.0;
      A[495] = 0.0;
      A[496] = 0.0;
      A[497] = 0.0;
      A[498] = 0.0;
      A[499] = 0.0;
      A[500] = 0.0;
      A[501] = 0.0;
      A[502] = 0.0;
      A[503] = 0.0;
      A[504] = 0.0;
      A[505] = 0.0;
      A[506] = 0.0;
      A[507] = 0.0;
      A[508] = 0.0;
      A[509] = 0.0;
      A[510] = 0.0;
      A[511] = 0.0;
      A[512] = 0.0;
      A[513] = 0.0666666666666666*G0_;
      A[514] = 0.0;
      A[515] = 0.0666666666666666*G0_;
      A[516] = 0.0;
      A[517] = 0.533333333333333*G0_;
      A[518] = 0.0;
      A[519] = 0.0;
      A[520] = 0.0;
      A[521] = 0.0;
      A[522] = 0.0;
      A[523] = 0.0;
      A[524] = 0.0;
      A[525] = 0.0;
      A[526] = 0.0;
      A[527] = 0.0;
      A[528] = 0.0;
      A[529] = 0.0;
      A[530] = 0.0;
      A[531] = 0.0;
      A[532] = 0.0;
      A[533] = 0.0;
      A[534] = 0.0;
      A[535] = 0.0;
      A[536] = 0.0;
      A[537] = 0.0;
      A[538] = 0.0;
      A[539] = 0.0;
      A[540] = 0.0;
      A[541] = 0.0;
      A[542] = 0.0;
      A[543] = 0.0;
      A[544] = 0.0;
      A[545] = 0.0;
      A[546] = 0.0;
      A[547] = 0.0;
      A[548] = 0.0;
      A[549] = 0.0;
      A[550] = 0.0;
      A[551] = 0.0;
      A[552] = 0.0;
      A[553] = 0.0;
      A[554] = 0.0;
      A[555] = 0.0;
      A[556] = 0.0;
      A[557] = 0.0;
      A[558] = 0.0;
      A[559] = 0.0;
      A[560] = 0.0;
      A[561] = 0.0;
      A[562] = 0.0;
      A[563] = 0.0;
      A[564] = 0.0;
      A[565] = 0.0;
      A[566] = 0.0;
      A[567] = 0.0;
      A[568] = 0.0;
      A[569] = 0.0;
      A[570] = 0.0;
      A[571] = 0.0;
      A[572] = 0.0;
      A[573] = 0.133333333333333*G1_;
      A[574] = 0.0;
      A[575] = -0.0333333333333333*G1_;
      A[576] = 0.0;
      A[577] = 0.0666666666666666*G1_;
      A[578] = 0.0;
      A[579] = 0.0;
      A[580] = 0.0;
      A[581] = 0.0;
      A[582] = 0.0;
      A[583] = 0.0;
      A[584] = 0.0;
      A[585] = 0.0;
      A[586] = 0.0;
      A[587] = 0.0;
      A[588] = 0.0;
      A[589] = 0.0;
      A[590] = 0.0;
      A[591] = 0.0;
      A[592] = 0.0;
      A[593] = 0.0;
      A[594] = 0.0;
      A[595] = 0.0;
      A[596] = 0.0;
      A[597] = 0.0;
      A[598] = 0.0;
      A[599] = 0.0;
      A[600] = 0.0;
      A[601] = 0.0;
      A[602] = 0.0;
      A[603] = 0.0;
      A[604] = 0.0;
      A[605] = 0.0;
      A[606] = 0.0;
      A[607] = 0.0;
      A[608] = 0.0;
      A[609] = 0.0;
      A[610] = 0.0;
      A[611] = 0.0;
      A[612] = 0.0;
      A[613] = 0.0;
      A[614] = 0.0;
      A[615] = 0.0;
      A[616] = 0.0;
      A[617] = 0.0;
      A[618] = 0.0;
      A[619] = 0.0;
      A[620] = 0.0;
      A[621] = 0.0;
      A[622] = 0.0;
      A[623] = 0.0;
      A[624] = 0.0;
      A[625] = 0.0;
      A[626] = 0.0;
      A[627] = -0.0333333333333333*G1_;
      A[628] = 0.0;
      A[629] = 0.133333333333333*G1_;
      A[630] = 0.0;
      A[631] = 0.0666666666666666*G1_;
      A[632] = 0.0;
      A[633] = 0.0;
      A[634] = 0.0;
      A[635] = 0.0;
      A[636] = 0.0;
      A[637] = 0.0;
      A[638] = 0.0;
      A[639] = 0.0;
      A[640] = 0.0;
      A[641] = 0.0;
      A[642] = 0.0;
      A[643] = 0.0;
      A[644] = 0.0;
      A[645] = 0.0;
      A[646] = 0.0;
      A[647] = 0.0;
      A[648] = 0.0;
      A[649] = 0.0;
      A[650] = 0.0;
      A[651] = 0.0;
      A[652] = 0.0;
      A[653] = 0.0;
      A[654] = 0.0;
      A[655] = 0.0;
      A[656] = 0.0;
      A[657] = 0.0;
      A[658] = 0.0;
      A[659] = 0.0;
      A[660] = 0.0;
      A[661] = 0.0;
      A[662] = 0.0;
      A[663] = 0.0;
      A[664] = 0.0;
      A[665] = 0.0;
      A[666] = 0.0;
      A[667] = 0.0;
      A[668] = 0.0;
      A[669] = 0.0;
      A[670] = 0.0;
      A[671] = 0.0;
      A[672] = 0.0;
      A[673] = 0.0;
      A[674] = 0.0;
      A[675] = 0.0;
      A[676] = 0.0;
      A[677] = 0.0;
      A[678] = 0.0;
      A[679] = 0.0;
      A[680] = 0.0;
      A[681] = 0.0666666666666666*G1_;
      A[682] = 0.0;
      A[683] = 0.0666666666666666*G1_;
      A[684] = 0.0;
      A[685] = 0.533333333333333*G1_;
      A[686] = 0.0;
      A[687] = 0.0;
      A[688] = 0.0;
      A[689] = 0.0;
      A[690] = 0.0;
      A[691] = 0.0;
      A[692] = 0.0;
      A[693] = 0.0;
      A[694] = 0.0;
      A[695] = 0.0;
      A[696] = 0.0;
      A[697] = 0.0;
      A[698] = 0.0;
      A[699] = 0.0;
      A[700] = 0.0;
      A[701] = 0.0;
      A[702] = 0.0;
      A[703] = 0.0;
      A[704] = 0.0;
      A[705] = 0.0;
      A[706] = 0.0;
      A[707] = 0.0;
      A[708] = 0.0;
      A[709] = 0.0;
      A[710] = 0.0;
      A[711] = 0.0;
      A[712] = 0.0;
      A[713] = 0.0;
      A[714] = 0.0;
      A[715] = 0.0;
      A[716] = 0.0;
      A[717] = 0.0;
      A[718] = 0.0;
      A[719] = 0.0;
      A[720] = 0.0;
      A[721] = 0.0;
      A[722] = 0.0;
      A[723] = 0.0;
      A[724] = 0.0;
      A[725] = 0.0;
      A[726] = 0.0;
      A[727] = 0.0;
      A[728] = 0.0;
        break;
      }
    case 2:
      {
        A[0] = 0.0;
      A[1] = 0.0;
      A[2] = 0.0;
      A[3] = 0.0;
      A[4] = 0.0;
      A[5] = 0.0;
      A[6] = 0.0;
      A[7] = 0.0;
      A[8] = 0.0;
      A[9] = 0.0;
      A[10] = 0.0;
      A[11] = 0.0;
      A[12] = 0.0;
      A[13] = 0.0;
      A[14] = 0.0;
      A[15] = 0.0;
      A[16] = 0.0;
      A[17] = 0.0;
      A[18] = 0.0;
      A[19] = 0.0;
      A[20] = 0.0;
      A[21] = 0.0;
      A[22] = 0.0;
      A[23] = 0.0;
      A[24] = 0.0;
      A[25] = 0.0;
      A[26] = 0.0;
      A[27] = 0.0;
      A[28] = 0.0;
      A[29] = 0.0;
      A[30] = 0.0;
      A[31] = 0.0;
      A[32] = 0.0;
      A[33] = 0.0;
      A[34] = 0.0;
      A[35] = 0.0;
      A[36] = 0.0;
      A[37] = 0.0;
      A[38] = 0.0;
      A[39] = 0.0;
      A[40] = 0.0;
      A[41] = 0.0;
      A[42] = 0.0;
      A[43] = 0.0;
      A[44] = 0.0;
      A[45] = 0.0;
      A[46] = 0.0;
      A[47] = 0.0;
      A[48] = 0.0;
      A[49] = 0.0;
      A[50] = 0.0;
      A[51] = 0.0;
      A[52] = 0.0;
      A[53] = 0.0;
      A[54] = 0.0;
      A[55] = 0.0;
      A[56] = 0.0;
      A[57] = 0.0;
      A[58] = 0.0;
      A[59] = 0.0;
      A[60] = 0.0;
      A[61] = 0.0;
      A[62] = 0.0;
      A[63] = 0.0;
      A[64] = 0.0;
      A[65] = 0.0;
      A[66] = 0.0;
      A[67] = 0.0;
      A[68] = 0.0;
      A[69] = 0.0;
      A[70] = 0.0;
      A[71] = 0.0;
      A[72] = 0.0;
      A[73] = 0.0;
      A[74] = 0.0;
      A[75] = 0.0;
      A[76] = 0.0;
      A[77] = 0.0;
      A[78] = 0.0;
      A[79] = 0.0;
      A[80] = 0.0;
      A[81] = 0.0;
      A[82] = 0.0;
      A[83] = 0.0;
      A[84] = 0.0;
      A[85] = 0.0;
      A[86] = 0.0;
      A[87] = 0.0;
      A[88] = 0.0;
      A[89] = 0.0;
      A[90] = 0.0;
      A[91] = 0.0;
      A[92] = 0.0;
      A[93] = 0.0;
      A[94] = 0.0;
      A[95] = 0.0;
      A[96] = 0.0;
      A[97] = 0.0;
      A[98] = 0.0;
      A[99] = 0.0;
      A[100] = 0.0;
      A[101] = 0.0;
      A[102] = 0.0;
      A[103] = 0.0;
      A[104] = 0.0;
      A[105] = 0.0;
      A[106] = 0.0;
      A[107] = 0.0;
      A[108] = 0.0;
      A[109] = 0.0;
      A[110] = 0.0;
      A[111] = 0.0;
      A[112] = 0.0;
      A[113] = 0.0;
      A[114] = 0.0;
      A[115] = 0.0;
      A[116] = 0.0;
      A[117] = 0.0;
      A[118] = 0.0;
      A[119] = 0.0;
      A[120] = 0.0;
      A[121] = 0.0;
      A[122] = 0.0;
      A[123] = 0.0;
      A[124] = 0.0;
      A[125] = 0.0;
      A[126] = 0.0;
      A[127] = 0.0;
      A[128] = 0.0;
      A[129] = 0.0;
      A[130] = 0.0;
      A[131] = 0.0;
      A[132] = 0.0;
      A[133] = 0.0;
      A[134] = 0.0;
      A[135] = 0.0;
      A[136] = 0.0;
      A[137] = 0.0;
      A[138] = 0.0;
      A[139] = 0.0;
      A[140] = 0.0;
      A[141] = 0.0;
      A[142] = 0.0;
      A[143] = 0.0;
      A[144] = 0.0;
      A[145] = 0.0;
      A[146] = 0.0;
      A[147] = 0.0;
      A[148] = 0.0;
      A[149] = 0.0;
      A[150] = 0.0;
      A[151] = 0.0;
      A[152] = 0.0;
      A[153] = 0.0;
      A[154] = 0.0;
      A[155] = 0.0;
      A[156] = 0.0;
      A[157] = 0.0;
      A[158] = 0.0;
      A[159] = 0.0;
      A[160] = 0.0;
      A[161] = 0.0;
      A[162] = 0.0;
      A[163] = 0.0;
      A[164] = 0.0;
      A[165] = 0.0;
      A[166] = 0.0;
      A[167] = 0.0;
      A[168] = 0.0;
      A[169] = 0.0;
      A[170] = 0.0;
      A[171] = 0.0;
      A[172] = 0.0;
      A[173] = 0.0;
      A[174] = 0.0;
      A[175] = 0.0;
      A[176] = 0.0;
      A[177] = 0.0;
      A[178] = 0.0;
      A[179] = 0.0;
      A[180] = 0.0;
      A[181] = 0.0;
      A[182] = 0.0;
      A[183] = 0.0;
      A[184] = 0.0;
      A[185] = 0.0;
      A[186] = 0.0;
      A[187] = 0.0;
      A[188] = 0.0;
      A[189] = 0.0;
      A[190] = 0.0;
      A[191] = 0.0;
      A[192] = 0.0;
      A[193] = 0.0;
      A[194] = 0.0;
      A[195] = 0.0;
      A[196] = 0.0;
      A[197] = 0.0;
      A[198] = 0.0;
      A[199] = 0.0;
      A[200] = 0.0;
      A[201] = 0.0;
      A[202] = 0.0;
      A[203] = 0.0;
      A[204] = 0.0;
      A[205] = 0.0;
      A[206] = 0.0;
      A[207] = 0.0;
      A[208] = 0.0;
      A[209] = 0.0;
      A[210] = 0.0;
      A[211] = 0.0;
      A[212] = 0.0;
      A[213] = 0.0;
      A[214] = 0.0;
      A[215] = 0.0;
      A[216] = 0.0;
      A[217] = 0.0;
      A[218] = 0.0;
      A[219] = 0.0;
      A[220] = 0.0;
      A[221] = 0.0;
      A[222] = 0.0;
      A[223] = 0.0;
      A[224] = 0.0;
      A[225] = 0.0;
      A[226] = 0.0;
      A[227] = 0.0;
      A[228] = 0.0;
      A[229] = 0.0;
      A[230] = 0.0;
      A[231] = 0.0;
      A[232] = 0.0;
      A[233] = 0.0;
      A[234] = 0.0;
      A[235] = 0.0;
      A[236] = 0.0;
      A[237] = 0.0;
      A[238] = 0.0;
      A[239] = 0.0;
      A[240] = 0.0;
      A[241] = 0.0;
      A[242] = 0.0;
      A[243] = 0.0;
      A[244] = 0.0;
      A[245] = 0.0;
      A[246] = 0.0;
      A[247] = 0.0;
      A[248] = 0.0;
      A[249] = 0.0;
      A[250] = 0.0;
      A[251] = 0.0;
      A[252] = 0.0;
      A[253] = 0.0;
      A[254] = 0.0;
      A[255] = 0.0;
      A[256] = 0.0;
      A[257] = 0.0;
      A[258] = 0.0;
      A[259] = 0.0;
      A[260] = 0.0;
      A[261] = 0.0;
      A[262] = 0.0;
      A[263] = 0.0;
      A[264] = 0.0;
      A[265] = 0.0;
      A[266] = 0.0;
      A[267] = 0.0;
      A[268] = 0.0;
      A[269] = 0.0;
      A[270] = 0.0;
      A[271] = 0.0;
      A[272] = 0.0;
      A[273] = 0.0;
      A[274] = 0.0;
      A[275] = 0.0;
      A[276] = 0.0;
      A[277] = 0.0;
      A[278] = 0.0;
      A[279] = 0.0;
      A[280] = 0.0;
      A[281] = 0.0;
      A[282] = 0.0;
      A[283] = 0.0;
      A[284] = 0.0;
      A[285] = 0.0;
      A[286] = 0.0;
      A[287] = 0.0;
      A[288] = 0.0;
      A[289] = 0.0;
      A[290] = 0.0;
      A[291] = 0.0;
      A[292] = 0.0;
      A[293] = 0.0;
      A[294] = 0.0;
      A[295] = 0.0;
      A[296] = 0.0;
      A[297] = 0.0;
      A[298] = 0.0;
      A[299] = 0.0;
      A[300] = 0.0;
      A[301] = 0.0;
      A[302] = 0.0;
      A[303] = 0.0;
      A[304] = 0.0;
      A[305] = 0.0;
      A[306] = 0.0;
      A[307] = 0.0;
      A[308] = 0.0;
      A[309] = 0.0;
      A[310] = 0.0;
      A[311] = 0.0;
      A[312] = 0.0;
      A[313] = 0.0;
      A[314] = 0.0;
      A[315] = 0.0;
      A[316] = 0.0;
      A[317] = 0.0;
      A[318] = 0.0;
      A[319] = 0.0;
      A[320] = 0.0;
      A[321] = 0.0;
      A[322] = 0.0;
      A[323] = 0.0;
      A[324] = 0.0;
      A[325] = 0.0;
      A[326] = 0.0;
      A[327] = 0.0;
      A[328] = 0.0;
      A[329] = 0.0;
      A[330] = 0.0;
      A[331] = 0.0;
      A[332] = 0.0;
      A[333] = 0.0;
      A[334] = 0.0;
      A[335] = 0.0;
      A[336] = 0.0;
      A[337] = 0.0;
      A[338] = 0.0;
      A[339] = 0.0;
      A[340] = 0.0;
      A[341] = 0.0;
      A[342] = 0.0;
      A[343] = 0.0;
      A[344] = 0.0;
      A[345] = 0.0;
      A[346] = 0.0;
      A[347] = 0.0;
      A[348] = 0.0;
      A[349] = 0.0;
      A[350] = 0.0;
      A[351] = 0.0;
      A[352] = 0.0;
      A[353] = 0.0;
      A[354] = 0.0;
      A[355] = 0.0;
      A[356] = 0.0;
      A[357] = 0.0;
      A[358] = 0.0;
      A[359] = 0.0;
      A[360] = 0.0;
      A[361] = 0.0;
      A[362] = 0.0;
      A[363] = 0.0;
      A[364] = 0.0;
      A[365] = 0.0;
      A[366] = 0.0;
      A[367] = 0.0;
      A[368] = 0.0;
      A[369] = 0.0;
      A[370] = 0.0;
      A[371] = 0.0;
      A[372] = 0.0;
      A[373] = 0.0;
      A[374] = 0.0;
      A[375] = 0.0;
      A[376] = 0.0;
      A[377] = 0.0;
      A[378] = 0.0;
      A[379] = 0.0;
      A[380] = 0.0;
      A[381] = 0.0;
      A[382] = 0.0;
      A[383] = 0.0;
      A[384] = 0.0;
      A[385] = 0.0;
      A[386] = 0.0;
      A[387] = 0.0;
      A[388] = 0.0;
      A[389] = 0.0;
      A[390] = 0.0;
      A[391] = 0.0;
      A[392] = 0.0;
      A[393] = 0.0;
      A[394] = 0.0;
      A[395] = 0.0;
      A[396] = 0.0;
      A[397] = 0.0;
      A[398] = 0.0;
      A[399] = 0.0;
      A[400] = 0.0;
      A[401] = 0.0;
      A[402] = 0.0;
      A[403] = 0.0;
      A[404] = 0.0;
      A[405] = 0.133333333333333*G0_;
      A[406] = -0.0333333333333333*G0_;
      A[407] = 0.0;
      A[408] = 0.0;
      A[409] = 0.0;
      A[410] = 0.0666666666666666*G0_;
      A[411] = 0.0;
      A[412] = 0.0;
      A[413] = 0.0;
      A[414] = 0.0;
      A[415] = 0.0;
      A[416] = 0.0;
      A[417] = 0.0;
      A[418] = 0.0;
      A[419] = 0.0;
      A[420] = 0.0;
      A[421] = 0.0;
      A[422] = 0.0;
      A[423] = 0.0;
      A[424] = 0.0;
      A[425] = 0.0;
      A[426] = 0.0;
      A[427] = 0.0;
      A[428] = 0.0;
      A[429] = 0.0;
      A[430] = 0.0;
      A[431] = 0.0;
      A[432] = -0.0333333333333333*G0_;
      A[433] = 0.133333333333333*G0_;
      A[434] = 0.0;
      A[435] = 0.0;
      A[436] = 0.0;
      A[437] = 0.0666666666666667*G0_;
      A[438] = 0.0;
      A[439] = 0.0;
      A[440] = 0.0;
      A[441] = 0.0;
      A[442] = 0.0;
      A[443] = 0.0;
      A[444] = 0.0;
      A[445] = 0.0;
      A[446] = 0.0;
      A[447] = 0.0;
      A[448] = 0.0;
      A[449] = 0.0;
      A[450] = 0.0;
      A[451] = 0.0;
      A[452] = 0.0;
      A[453] = 0.0;
      A[454] = 0.0;
      A[455] = 0.0;
      A[456] = 0.0;
      A[457] = 0.0;
      A[458] = 0.0;
      A[459] = 0.0;
      A[460] = 0.0;
      A[461] = 0.0;
      A[462] = 0.0;
      A[463] = 0.0;
      A[464] = 0.0;
      A[465] = 0.0;
      A[466] = 0.0;
      A[467] = 0.0;
      A[468] = 0.0;
      A[469] = 0.0;
      A[470] = 0.0;
      A[471] = 0.0;
      A[472] = 0.0;
      A[473] = 0.0;
      A[474] = 0.0;
      A[475] = 0.0;
      A[476] = 0.0;
      A[477] = 0.0;
      A[478] = 0.0;
      A[479] = 0.0;
      A[480] = 0.0;
      A[481] = 0.0;
      A[482] = 0.0;
      A[483] = 0.0;
      A[484] = 0.0;
      A[485] = 0.0;
      A[486] = 0.0;
      A[487] = 0.0;
      A[488] = 0.0;
      A[489] = 0.0;
      A[490] = 0.0;
      A[491] = 0.0;
      A[492] = 0.0;
      A[493] = 0.0;
      A[494] = 0.0;
      A[495] = 0.0;
      A[496] = 0.0;
      A[497] = 0.0;
      A[498] = 0.0;
      A[499] = 0.0;
      A[500] = 0.0;
      A[501] = 0.0;
      A[502] = 0.0;
      A[503] = 0.0;
      A[504] = 0.0;
      A[505] = 0.0;
      A[506] = 0.0;
      A[507] = 0.0;
      A[508] = 0.0;
      A[509] = 0.0;
      A[510] = 0.0;
      A[511] = 0.0;
      A[512] = 0.0;
      A[513] = 0.0;
      A[514] = 0.0;
      A[515] = 0.0;
      A[516] = 0.0;
      A[517] = 0.0;
      A[518] = 0.0;
      A[519] = 0.0;
      A[520] = 0.0;
      A[521] = 0.0;
      A[522] = 0.0;
      A[523] = 0.0;
      A[524] = 0.0;
      A[525] = 0.0;
      A[526] = 0.0;
      A[527] = 0.0;
      A[528] = 0.0;
      A[529] = 0.0;
      A[530] = 0.0;
      A[531] = 0.0;
      A[532] = 0.0;
      A[533] = 0.0;
      A[534] = 0.0;
      A[535] = 0.0;
      A[536] = 0.0;
      A[537] = 0.0;
      A[538] = 0.0;
      A[539] = 0.0;
      A[540] = 0.0666666666666666*G0_;
      A[541] = 0.0666666666666667*G0_;
      A[542] = 0.0;
      A[543] = 0.0;
      A[544] = 0.0;
      A[545] = 0.533333333333333*G0_;
      A[546] = 0.0;
      A[547] = 0.0;
      A[548] = 0.0;
      A[549] = 0.0;
      A[550] = 0.0;
      A[551] = 0.0;
      A[552] = 0.0;
      A[553] = 0.0;
      A[554] = 0.0;
      A[555] = 0.0;
      A[556] = 0.0;
      A[557] = 0.0;
      A[558] = 0.0;
      A[559] = 0.0;
      A[560] = 0.0;
      A[561] = 0.0;
      A[562] = 0.0;
      A[563] = 0.0;
      A[564] = 0.0;
      A[565] = 0.0;
      A[566] = 0.0;
      A[567] = 0.0;
      A[568] = 0.0;
      A[569] = 0.0;
      A[570] = 0.0;
      A[571] = 0.0;
      A[572] = 0.0;
      A[573] = 0.133333333333333*G1_;
      A[574] = -0.0333333333333333*G1_;
      A[575] = 0.0;
      A[576] = 0.0;
      A[577] = 0.0;
      A[578] = 0.0666666666666666*G1_;
      A[579] = 0.0;
      A[580] = 0.0;
      A[581] = 0.0;
      A[582] = 0.0;
      A[583] = 0.0;
      A[584] = 0.0;
      A[585] = 0.0;
      A[586] = 0.0;
      A[587] = 0.0;
      A[588] = 0.0;
      A[589] = 0.0;
      A[590] = 0.0;
      A[591] = 0.0;
      A[592] = 0.0;
      A[593] = 0.0;
      A[594] = 0.0;
      A[595] = 0.0;
      A[596] = 0.0;
      A[597] = 0.0;
      A[598] = 0.0;
      A[599] = 0.0;
      A[600] = -0.0333333333333333*G1_;
      A[601] = 0.133333333333333*G1_;
      A[602] = 0.0;
      A[603] = 0.0;
      A[604] = 0.0;
      A[605] = 0.0666666666666667*G1_;
      A[606] = 0.0;
      A[607] = 0.0;
      A[608] = 0.0;
      A[609] = 0.0;
      A[610] = 0.0;
      A[611] = 0.0;
      A[612] = 0.0;
      A[613] = 0.0;
      A[614] = 0.0;
      A[615] = 0.0;
      A[616] = 0.0;
      A[617] = 0.0;
      A[618] = 0.0;
      A[619] = 0.0;
      A[620] = 0.0;
      A[621] = 0.0;
      A[622] = 0.0;
      A[623] = 0.0;
      A[624] = 0.0;
      A[625] = 0.0;
      A[626] = 0.0;
      A[627] = 0.0;
      A[628] = 0.0;
      A[629] = 0.0;
      A[630] = 0.0;
      A[631] = 0.0;
      A[632] = 0.0;
      A[633] = 0.0;
      A[634] = 0.0;
      A[635] = 0.0;
      A[636] = 0.0;
      A[637] = 0.0;
      A[638] = 0.0;
      A[639] = 0.0;
      A[640] = 0.0;
      A[641] = 0.0;
      A[642] = 0.0;
      A[643] = 0.0;
      A[644] = 0.0;
      A[645] = 0.0;
      A[646] = 0.0;
      A[647] = 0.0;
      A[648] = 0.0;
      A[649] = 0.0;
      A[650] = 0.0;
      A[651] = 0.0;
      A[652] = 0.0;
      A[653] = 0.0;
      A[654] = 0.0;
      A[655] = 0.0;
      A[656] = 0.0;
      A[657] = 0.0;
      A[658] = 0.0;
      A[659] = 0.0;
      A[660] = 0.0;
      A[661] = 0.0;
      A[662] = 0.0;
      A[663] = 0.0;
      A[664] = 0.0;
      A[665] = 0.0;
      A[666] = 0.0;
      A[667] = 0.0;
      A[668] = 0.0;
      A[669] = 0.0;
      A[670] = 0.0;
      A[671] = 0.0;
      A[672] = 0.0;
      A[673] = 0.0;
      A[674] = 0.0;
      A[675] = 0.0;
      A[676] = 0.0;
      A[677] = 0.0;
      A[678] = 0.0;
      A[679] = 0.0;
      A[680] = 0.0;
      A[681] = 0.0;
      A[682] = 0.0;
      A[683] = 0.0;
      A[684] = 0.0;
      A[685] = 0.0;
      A[686] = 0.0;
      A[687] = 0.0;
      A[688] = 0.0;
      A[689] = 0.0;
      A[690] = 0.0;
      A[691] = 0.0;
      A[692] = 0.0;
      A[693] = 0.0;
      A[694] = 0.0;
      A[695] = 0.0;
      A[696] = 0.0;
      A[697] = 0.0;
      A[698] = 0.0;
      A[699] = 0.0;
      A[700] = 0.0;
      A[701] = 0.0;
      A[702] = 0.0;
      A[703] = 0.0;
      A[704] = 0.0;
      A[705] = 0.0;
      A[706] = 0.0;
      A[707] = 0.0;
      A[708] = 0.0666666666666666*G1_;
      A[709] = 0.0666666666666667*G1_;
      A[710] = 0.0;
      A[711] = 0.0;
      A[712] = 0.0;
      A[713] = 0.533333333333333*G1_;
      A[714] = 0.0;
      A[715] = 0.0;
      A[716] = 0.0;
      A[717] = 0.0;
      A[718] = 0.0;
      A[719] = 0.0;
      A[720] = 0.0;
      A[721] = 0.0;
      A[722] = 0.0;
      A[723] = 0.0;
      A[724] = 0.0;
      A[725] = 0.0;
      A[726] = 0.0;
      A[727] = 0.0;
      A[728] = 0.0;
        break;
      }
    }
    
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not available when using the FFC tensor representation.");
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_form_0: public ufc::form
{
public:

  /// Constructor
  ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_form_0() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_form_0()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Sum(Product(IntValue(-1, (), (), {}), Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None)], **{'value_shape': (5,) }), 1), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None)], **{'value_shape': (5,) }), 1), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((Index(0),), {Index(0): 2})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None)], **{'value_shape': (5,) }), 0), MultiIndex((FixedIndex(2),), {})))), Sum(Product(FloatValue(0.001, (), (), {}), IndexSum(IndexSum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None)], **{'value_shape': (5,) }), 0), MultiIndex((Index(1),), {Index(1): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None)], **{'value_shape': (5,) }), 0), MultiIndex((Index(1),), {Index(1): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(2),), {Index(2): 2})), MultiIndex((Index(2), Index(1)), {Index(2): 2, Index(1): 2})), MultiIndex((Index(3), Index(4)), {Index(4): 2, Index(3): 2})), Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None)], **{'value_shape': (5,) }), 1), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None)], **{'value_shape': (5,) }), 1), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((Index(6), Index(5)), {Index(5): 2, Index(6): 2})), MultiIndex((Index(3), Index(4)), {Index(4): 2, Index(3): 2}))), MultiIndex((Index(3),), {Index(3): 2})), MultiIndex((Index(4),), {Index(4): 2}))), Product(IntValue(-1, (), (), {}), Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None)], **{'value_shape': (5,) }), 0), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None)], **{'value_shape': (5,) }), 0), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((Index(7),), {Index(7): 2})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None)], **{'value_shape': (5,) }), 1), MultiIndex((FixedIndex(2),), {})))))), Measure('cell', 0, None)), Integral(IndexSum(Product(Indexed(ListTensor(Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None)], **{'value_shape': (5,) }), 0), MultiIndex((FixedIndex(3),), {})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None)], **{'value_shape': (5,) }), 0), MultiIndex((FixedIndex(4),), {}))), MultiIndex((Index(8),), {Index(8): 2})), Indexed(ListTensor(Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None)], **{'value_shape': (5,) }), 1), MultiIndex((FixedIndex(0),), {})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None)], **{'value_shape': (5,) }), 1), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(8),), {Index(8): 2}))), MultiIndex((Index(8),), {Index(8): 2})), Measure('exterior_facet', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 2;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 0;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 1;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 1;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_3();
        break;
      }
    case 1:
      {
        return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_finite_element_3();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_3();
        break;
      }
    case 1:
      {
        return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_dofmap_3();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_cell_integral_0_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new ffc_form_b6635f4d172075e6d0547c88224152db1a4f3a89_exterior_facet_integral_0_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

#endif
